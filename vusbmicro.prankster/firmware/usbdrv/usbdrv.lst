GAS LISTING /tmp/ccOpHXKC.s 			page 1


   1               		.file	"usbdrv.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.stabs	"/home/chris/avr/vusbtiny/",100,0,2,.Ltext0
  11               		.stabs	"usbdrv/usbdrv.c",100,0,2,.Ltext0
  12               		.text
  13               	.Ltext0:
  14               		.stabs	"gcc2_compiled.",60,0,0,0
  15               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,1,0
  16               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,1,0
  17               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,1,0
  18               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,1,0
  19               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,1,0
  20               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,1,
  21               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,1,0
  22               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,1,0
  23               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,1,0
  24               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,1,0
  25               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,1,0
  26               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,1,0
  27               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,1,0
  28               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,1,0
  29               		.stabs	"void:t(0,15)=(0,15)",128,0,1,0
  30               		.stabs	"usbdrv/usbportability.h",130,0,0,0
  31               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h",130,0,0,0
  32               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/sfr_defs.h",130,0,0,0
  33               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/inttypes.h",130,0,0,0
  34               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdint.h",130,0,0,0
  35               		.stabs	"int8_t:t(5,1)=(0,10)",128,0,121,0
  36               		.stabs	"uint8_t:t(5,2)=(0,11)",128,0,122,0
  37               		.stabs	"int16_t:t(5,3)=(0,1)",128,0,123,0
  38               		.stabs	"uint16_t:t(5,4)=(0,4)",128,0,124,0
  39               		.stabs	"int32_t:t(5,5)=(0,3)",128,0,125,0
  40               		.stabs	"uint32_t:t(5,6)=(0,5)",128,0,126,0
  41               		.stabs	"int64_t:t(5,7)=(0,6)",128,0,128,0
  42               		.stabs	"uint64_t:t(5,8)=(0,7)",128,0,129,0
  43               		.stabs	"intptr_t:t(5,9)=(5,3)",128,0,142,0
  44               		.stabs	"uintptr_t:t(5,10)=(5,4)",128,0,147,0
  45               		.stabs	"int_least8_t:t(5,11)=(5,1)",128,0,159,0
  46               		.stabs	"uint_least8_t:t(5,12)=(5,2)",128,0,164,0
  47               		.stabs	"int_least16_t:t(5,13)=(5,3)",128,0,169,0
  48               		.stabs	"uint_least16_t:t(5,14)=(5,4)",128,0,174,0
  49               		.stabs	"int_least32_t:t(5,15)=(5,5)",128,0,179,0
  50               		.stabs	"uint_least32_t:t(5,16)=(5,6)",128,0,184,0
  51               		.stabs	"int_least64_t:t(5,17)=(5,7)",128,0,192,0
  52               		.stabs	"uint_least64_t:t(5,18)=(5,8)",128,0,199,0
  53               		.stabs	"int_fast8_t:t(5,19)=(5,1)",128,0,213,0
  54               		.stabs	"uint_fast8_t:t(5,20)=(5,2)",128,0,218,0
  55               		.stabs	"int_fast16_t:t(5,21)=(5,3)",128,0,223,0
  56               		.stabs	"uint_fast16_t:t(5,22)=(5,4)",128,0,228,0
  57               		.stabs	"int_fast32_t:t(5,23)=(5,5)",128,0,233,0
GAS LISTING /tmp/ccOpHXKC.s 			page 2


  58               		.stabs	"uint_fast32_t:t(5,24)=(5,6)",128,0,238,0
  59               		.stabs	"int_fast64_t:t(5,25)=(5,7)",128,0,246,0
  60               		.stabs	"uint_fast64_t:t(5,26)=(5,8)",128,0,253,0
  61               		.stabs	"intmax_t:t(5,27)=(5,7)",128,0,273,0
  62               		.stabs	"uintmax_t:t(5,28)=(5,8)",128,0,278,0
  63               		.stabn	162,0,0,0
  64               		.stabs	"int_farptr_t:t(4,1)=(5,5)",128,0,77,0
  65               		.stabs	"uint_farptr_t:t(4,2)=(5,6)",128,0,81,0
  66               		.stabn	162,0,0,0
  67               		.stabn	162,0,0,0
  68               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/fuse.h",130,0,0,0
  69               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,239,0
  70               		.stabn	162,0,0,0
  71               		.stabn	162,0,0,0
  72               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/pgmspace.h",130,0,0,0
  73               		.stabs	"/usr/lib/gcc/avr/4.3.4/include/stddef.h",130,0,0,0
  74               		.stabs	"size_t:t(8,1)=(0,4)",128,0,214,0
  75               		.stabn	162,0,0,0
  76               		.stabs	"prog_void:t(7,1)=(7,2)=(7,2)",128,0,211,0
  77               		.stabs	"prog_char:t(7,3)=(7,4)=@s8;r(7,4);0;255;",128,0,212,0
  78               		.stabs	"prog_uchar:t(7,5)=(7,4)",128,0,213,0
  79               		.stabs	"prog_int8_t:t(7,6)=(7,7)=(0,10)",128,0,215,0
  80               		.stabs	"prog_uint8_t:t(7,8)=(7,4)",128,0,216,0
  81               		.stabs	"prog_int16_t:t(7,9)=(7,10)=(0,1)",128,0,217,0
  82               		.stabs	"prog_uint16_t:t(7,11)=(7,12)=(0,4)",128,0,218,0
  83               		.stabs	"prog_int32_t:t(7,13)=(7,14)=(0,3)",128,0,219,0
  84               		.stabs	"prog_uint32_t:t(7,15)=(7,16)=(0,5)",128,0,220,0
  85               		.stabs	"prog_int64_t:t(7,17)=(7,18)=(0,6)",128,0,222,0
  86               		.stabs	"prog_uint64_t:t(7,19)=(7,20)=(0,7)",128,0,223,0
  87               		.stabn	162,0,0,0
  88               		.stabn	162,0,0,0
  89               		.stabs	"usbdrv/usbdrv.h",130,0,0,0
  90               		.stabs	"usbTxStatus:T(9,1)=s12len:(9,2)=B(0,11),0,8;buffer:(9,3)=ar(9,4)=r(9,4);0;0177777;;0;10;(0
  91               		.stabs	"usbTxStatus_t:t(9,5)=(9,1)",128,0,650,0
  92               		.stabs	"usbWord:T(9,6)=u2word:(0,4),0,16;bytes:(9,7)=ar(9,4);0;1;(0,11),0,16;;",128,0,0,0
  93               		.stabs	"usbWord_t:t(9,8)=(9,6)",128,0,662,0
  94               		.stabs	"usbRequest:T(9,9)=s8bmRequestType:(0,11),0,8;bRequest:(0,11),8,8;wValue:(9,8),16,16;wIndex
  95               		.stabs	"usbRequest_t:t(9,10)=(9,9)",128,0,670,0
  96               		.stabn	162,0,0,0
  97               		.stabs	"usbInit:F(0,15)",36,0,609,usbInit
  98               	.global	usbInit
  99               		.type	usbInit, @function
 100               	usbInit:
 101               		.stabd	46,0,0
   0:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   1:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   2:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   3:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   4:usbdrv/usbdrv.c ****  * Tabsize: 4
   5:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   6:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   7:usbdrv/usbdrv.c ****  * This Revision: $Id: usbdrv.c 763 2009-08-22 10:27:24Z cs $
   8:usbdrv/usbdrv.c ****  */
   9:usbdrv/usbdrv.c **** 
  10:usbdrv/usbdrv.c **** #include "usbportability.h"
  11:usbdrv/usbdrv.c **** #include "usbdrv.h"
  12:usbdrv/usbdrv.c **** #include "oddebug.h"
GAS LISTING /tmp/ccOpHXKC.s 			page 3


  13:usbdrv/usbdrv.c **** 
  14:usbdrv/usbdrv.c **** /*
  15:usbdrv/usbdrv.c **** General Description:
  16:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  17:usbdrv/usbdrv.c **** documentation of the entire driver.
  18:usbdrv/usbdrv.c **** */
  19:usbdrv/usbdrv.c **** 
  20:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  21:usbdrv/usbdrv.c **** 
  22:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  23:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  24:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  25:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  26:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  27:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  28:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  29:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  30:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  31:usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  32:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  33:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  34:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  35:usbdrv/usbdrv.c **** #endif
  36:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  37:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  38:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  39:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  40:usbdrv/usbdrv.c **** #   endif
  41:usbdrv/usbdrv.c **** #endif
  42:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  43:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  44:usbdrv/usbdrv.c **** #endif
  45:usbdrv/usbdrv.c **** 
  46:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  47:usbdrv/usbdrv.c **** uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
  48:usbdrv/usbdrv.c **** static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  49:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  50:usbdrv/usbdrv.c **** 
  51:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  52:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  53:usbdrv/usbdrv.c **** 
  54:usbdrv/usbdrv.c **** /*
  55:usbdrv/usbdrv.c **** optimizing hints:
  56:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  57:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  58:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  59:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  60:usbdrv/usbdrv.c **** */
  61:usbdrv/usbdrv.c **** 
  62:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  63:usbdrv/usbdrv.c **** 
  64:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  65:usbdrv/usbdrv.c **** 
  66:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  67:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  68:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  69:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorString0[] = { /* language descriptor */
GAS LISTING /tmp/ccOpHXKC.s 			page 4


  70:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  71:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  72:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  73:usbdrv/usbdrv.c **** };
  74:usbdrv/usbdrv.c **** #endif
  75:usbdrv/usbdrv.c **** 
  76:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  77:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  78:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  79:usbdrv/usbdrv.c **** PROGMEM int  usbDescriptorStringVendor[] = {
  80:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
  81:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  82:usbdrv/usbdrv.c **** };
  83:usbdrv/usbdrv.c **** #endif
  84:usbdrv/usbdrv.c **** 
  85:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  86:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  87:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  88:usbdrv/usbdrv.c **** PROGMEM int  usbDescriptorStringDevice[] = {
  89:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  90:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  91:usbdrv/usbdrv.c **** };
  92:usbdrv/usbdrv.c **** #endif
  93:usbdrv/usbdrv.c **** 
  94:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
  95:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
  96:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
  97:usbdrv/usbdrv.c **** PROGMEM int usbDescriptorStringSerialNumber[] = {
  98:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
  99:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 100:usbdrv/usbdrv.c **** };
 101:usbdrv/usbdrv.c **** #endif
 102:usbdrv/usbdrv.c **** 
 103:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 104:usbdrv/usbdrv.c **** 
 105:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 106:usbdrv/usbdrv.c **** 
 107:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 108:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 109:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 110:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
 111:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 112:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 113:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 114:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 115:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 116:usbdrv/usbdrv.c ****     0,                      /* protocol */
 117:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 118:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 119:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 120:usbdrv/usbdrv.c ****      */
 121:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 122:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 123:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 124:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 125:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 126:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
GAS LISTING /tmp/ccOpHXKC.s 			page 5


 127:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 128:usbdrv/usbdrv.c **** };
 129:usbdrv/usbdrv.c **** #endif
 130:usbdrv/usbdrv.c **** 
 131:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 132:usbdrv/usbdrv.c **** 
 133:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 134:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 135:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 136:usbdrv/usbdrv.c **** #endif
 137:usbdrv/usbdrv.c **** 
 138:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 139:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 140:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 141:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 142:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 143:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 144:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 145:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 146:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 147:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 148:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 149:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 150:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 151:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 152:usbdrv/usbdrv.c **** #else
 153:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 154:usbdrv/usbdrv.c **** #endif
 155:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 156:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 157:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 158:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 159:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 160:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 161:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 162:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 163:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 164:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 165:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 166:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 167:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 168:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 169:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 170:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 171:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 172:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 173:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 174:usbdrv/usbdrv.c **** #endif
 175:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 176:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 177:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 178:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 179:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 180:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 181:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 182:usbdrv/usbdrv.c **** #endif
 183:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
GAS LISTING /tmp/ccOpHXKC.s 			page 6


 184:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 185:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 186:usbdrv/usbdrv.c ****     (char)0x83, /* IN endpoint number 1 */
 187:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 188:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 189:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 190:usbdrv/usbdrv.c **** #endif
 191:usbdrv/usbdrv.c **** };
 192:usbdrv/usbdrv.c **** #endif
 193:usbdrv/usbdrv.c **** 
 194:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 195:usbdrv/usbdrv.c **** 
 196:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 197:usbdrv/usbdrv.c **** {
 198:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 199:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 200:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 201:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 202:usbdrv/usbdrv.c **** #   endif
 203:usbdrv/usbdrv.c **** #endif
 204:usbdrv/usbdrv.c **** }
 205:usbdrv/usbdrv.c **** 
 206:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 207:usbdrv/usbdrv.c **** {
 208:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 209:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 210:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 211:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 212:usbdrv/usbdrv.c **** #endif
 213:usbdrv/usbdrv.c **** #endif
 214:usbdrv/usbdrv.c **** }
 215:usbdrv/usbdrv.c **** 
 216:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 217:usbdrv/usbdrv.c **** 
 218:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 219:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 220:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 221:usbdrv/usbdrv.c **** {
 222:usbdrv/usbdrv.c **** uchar   *p;
 223:usbdrv/usbdrv.c **** char    i;
 224:usbdrv/usbdrv.c **** 
 225:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 226:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 227:usbdrv/usbdrv.c ****         return;
 228:usbdrv/usbdrv.c **** #endif
 229:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 230:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 231:usbdrv/usbdrv.c ****     }else{
 232:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 233:usbdrv/usbdrv.c ****     }
 234:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 235:usbdrv/usbdrv.c ****     i = len;
 236:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 237:usbdrv/usbdrv.c ****         *p++ = *data++;
 238:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 239:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 240:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
GAS LISTING /tmp/ccOpHXKC.s 			page 7


 241:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 242:usbdrv/usbdrv.c **** }
 243:usbdrv/usbdrv.c **** 
 244:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 245:usbdrv/usbdrv.c **** {
 246:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 247:usbdrv/usbdrv.c **** }
 248:usbdrv/usbdrv.c **** #endif
 249:usbdrv/usbdrv.c **** 
 250:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 251:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 252:usbdrv/usbdrv.c **** {
 253:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 254:usbdrv/usbdrv.c **** }
 255:usbdrv/usbdrv.c **** #endif
 256:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 257:usbdrv/usbdrv.c **** 
 258:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 259:usbdrv/usbdrv.c **** 
 260:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 261:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 262:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 263:usbdrv/usbdrv.c ****  * cases.
 264:usbdrv/usbdrv.c ****  */
 265:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 266:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 267:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 268:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 269:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 270:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 271:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 272:usbdrv/usbdrv.c **** #else
 273:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 274:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 275:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 276:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
 277:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 278:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 279:usbdrv/usbdrv.c **** #endif
 280:usbdrv/usbdrv.c **** 
 281:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 282:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 283:usbdrv/usbdrv.c **** #endif
 284:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 285:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 286:usbdrv/usbdrv.c **** #endif
 287:usbdrv/usbdrv.c **** 
 288:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 289:usbdrv/usbdrv.c **** 
 290:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 291:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 292:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 293:usbdrv/usbdrv.c ****  * optimizing!
 294:usbdrv/usbdrv.c ****  */
 295:usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 296:usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 297:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
GAS LISTING /tmp/ccOpHXKC.s 			page 8


 298:usbdrv/usbdrv.c ****             flags = 0;                              \
 299:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 300:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);        \
 301:usbdrv/usbdrv.c ****         }else{                                      \
 302:usbdrv/usbdrv.c ****             len = USB_PROP_LENGTH(cfgProp);         \
 303:usbdrv/usbdrv.c ****             usbMsgPtr = (uchar *)(staticName);      \
 304:usbdrv/usbdrv.c ****         }                                           \
 305:usbdrv/usbdrv.c ****     }
 306:usbdrv/usbdrv.c **** 
 307:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 308:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 309:usbdrv/usbdrv.c ****  */
 310:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 311:usbdrv/usbdrv.c **** {
 312:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 313:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 314:usbdrv/usbdrv.c **** 
 315:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 316:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 317:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 318:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 319:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 320:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 321:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 322:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 323:usbdrv/usbdrv.c ****             flags = 0;
 324:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 325:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 326:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 327:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 328:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 329:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 330:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 331:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 332:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 333:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 334:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 335:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 336:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 337:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 338:usbdrv/usbdrv.c ****             }
 339:usbdrv/usbdrv.c ****         SWITCH_END
 340:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 341:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 342:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 343:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 344:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 345:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 346:usbdrv/usbdrv.c **** #endif
 347:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 348:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 349:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 350:usbdrv/usbdrv.c ****         }
 351:usbdrv/usbdrv.c ****     SWITCH_END
 352:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 353:usbdrv/usbdrv.c ****     return len;
 354:usbdrv/usbdrv.c **** }
GAS LISTING /tmp/ccOpHXKC.s 			page 9


 355:usbdrv/usbdrv.c **** 
 356:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 357:usbdrv/usbdrv.c **** 
 358:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 359:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 360:usbdrv/usbdrv.c ****  */
 361:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 362:usbdrv/usbdrv.c **** {
 363:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 365:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 366:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
 367:usbdrv/usbdrv.c **** #endif
 368:usbdrv/usbdrv.c **** 
 369:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 370:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 371:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 372:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 373:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 374:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 375:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 376:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 377:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 378:usbdrv/usbdrv.c **** #endif
 379:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 380:usbdrv/usbdrv.c ****         len = 2;
 381:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 382:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 383:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 384:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 385:usbdrv/usbdrv.c ****             usbResetDataToggling();
 386:usbdrv/usbdrv.c ****         }
 387:usbdrv/usbdrv.c **** #endif
 388:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 389:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 390:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 391:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 392:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 393:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 394:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 395:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 396:usbdrv/usbdrv.c ****         len = 1;
 397:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 398:usbdrv/usbdrv.c ****         usbConfiguration = value;
 399:usbdrv/usbdrv.c ****         usbResetStall();
 400:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 401:usbdrv/usbdrv.c ****         len = 1;
 402:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 403:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 404:usbdrv/usbdrv.c ****         usbResetDataToggling();
 405:usbdrv/usbdrv.c ****         usbResetStall();
 406:usbdrv/usbdrv.c **** #endif
 407:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 408:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 409:usbdrv/usbdrv.c ****     SWITCH_END
 410:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 411:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
GAS LISTING /tmp/ccOpHXKC.s 			page 10


 412:usbdrv/usbdrv.c ****     return len;
 413:usbdrv/usbdrv.c **** }
 414:usbdrv/usbdrv.c **** 
 415:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 416:usbdrv/usbdrv.c **** 
 417:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 418:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 419:usbdrv/usbdrv.c ****  * them accordingly.
 420:usbdrv/usbdrv.c ****  */
 421:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 422:usbdrv/usbdrv.c **** {
 423:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 424:usbdrv/usbdrv.c **** 
 425:usbdrv/usbdrv.c **** /* usbRxToken can be:
 426:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 427:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 428:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 429:usbdrv/usbdrv.c ****  */
 430:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 431:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 432:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 433:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 434:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 435:usbdrv/usbdrv.c ****         return;
 436:usbdrv/usbdrv.c ****     }
 437:usbdrv/usbdrv.c **** #endif
 438:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 439:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 440:usbdrv/usbdrv.c ****             return;
 441:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 442:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 443:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 444:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 445:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 446:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 447:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 448:usbdrv/usbdrv.c **** 			// 2010.04.29 chrisc need this to work w/ usbtiny
 449:usbdrv/usbdrv.c ****         }else{
 450:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 451:usbdrv/usbdrv.c ****         }
 452:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 453:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 454:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 455:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 456:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 457:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 458:usbdrv/usbdrv.c ****                 }else{
 459:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 460:usbdrv/usbdrv.c ****                 }
 461:usbdrv/usbdrv.c ****             }
 462:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 463:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 464:usbdrv/usbdrv.c **** #endif
 465:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 466:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 467:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 468:usbdrv/usbdrv.c ****         }else{
GAS LISTING /tmp/ccOpHXKC.s 			page 11


 469:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 470:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 471:usbdrv/usbdrv.c ****         }
 472:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 473:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 474:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 475:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 476:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 477:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 478:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 479:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 480:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 481:usbdrv/usbdrv.c ****             }
 482:usbdrv/usbdrv.c ****         }
 483:usbdrv/usbdrv.c **** #endif
 484:usbdrv/usbdrv.c ****     }
 485:usbdrv/usbdrv.c **** }
 486:usbdrv/usbdrv.c **** 
 487:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 488:usbdrv/usbdrv.c **** 
 489:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 490:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 491:usbdrv/usbdrv.c ****  */
 492:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 493:usbdrv/usbdrv.c **** {
 494:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 495:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 496:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 497:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 498:usbdrv/usbdrv.c ****         }else
 499:usbdrv/usbdrv.c **** #endif
 500:usbdrv/usbdrv.c ****         {
 501:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 503:usbdrv/usbdrv.c ****                 do{
 504:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 505:usbdrv/usbdrv.c ****                     *data++ = c;
 506:usbdrv/usbdrv.c ****                     r++;
 507:usbdrv/usbdrv.c ****                 }while(--i);
 508:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 509:usbdrv/usbdrv.c ****                 do{
 510:usbdrv/usbdrv.c ****                     *data++ = *r++;
 511:usbdrv/usbdrv.c ****                 }while(--i);
 512:usbdrv/usbdrv.c ****             }
 513:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 514:usbdrv/usbdrv.c ****         }
 515:usbdrv/usbdrv.c ****     }
 516:usbdrv/usbdrv.c ****     return len;
 517:usbdrv/usbdrv.c **** }
 518:usbdrv/usbdrv.c **** 
 519:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 520:usbdrv/usbdrv.c **** 
 521:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 522:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 523:usbdrv/usbdrv.c ****  */
 524:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 525:usbdrv/usbdrv.c **** {
GAS LISTING /tmp/ccOpHXKC.s 			page 12


 526:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 527:usbdrv/usbdrv.c **** uchar       len;
 528:usbdrv/usbdrv.c **** 
 529:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 530:usbdrv/usbdrv.c ****     if(wantLen > 8)
 531:usbdrv/usbdrv.c ****         wantLen = 8;
 532:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 533:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 534:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 535:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 536:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 537:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 538:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 539:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 540:usbdrv/usbdrv.c ****     }else{
 541:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 542:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 543:usbdrv/usbdrv.c ****     }
 544:usbdrv/usbdrv.c ****     usbTxLen = len;
 545:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 546:usbdrv/usbdrv.c **** }
 547:usbdrv/usbdrv.c **** 
 548:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 549:usbdrv/usbdrv.c **** 
 550:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 551:usbdrv/usbdrv.c **** {
 552:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 553:usbdrv/usbdrv.c **** static uchar    wasReset;
 554:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 555:usbdrv/usbdrv.c **** 
 556:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 557:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 558:usbdrv/usbdrv.c ****         wasReset = isReset;
 559:usbdrv/usbdrv.c ****     }
 560:usbdrv/usbdrv.c **** #endif
 561:usbdrv/usbdrv.c **** }
 562:usbdrv/usbdrv.c **** 
 563:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 564:usbdrv/usbdrv.c **** 
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 566:usbdrv/usbdrv.c **** {
 567:usbdrv/usbdrv.c **** schar   len;
 568:usbdrv/usbdrv.c **** uchar   i;
 569:usbdrv/usbdrv.c **** 
 570:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 571:usbdrv/usbdrv.c ****     if(len >= 0){
 572:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 573:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 574:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 575:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 576:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 577:usbdrv/usbdrv.c ****  */
 578:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 579:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 580:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 581:usbdrv/usbdrv.c ****             usbRxLen = 0;
 582:usbdrv/usbdrv.c **** #else
GAS LISTING /tmp/ccOpHXKC.s 			page 13


 583:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 584:usbdrv/usbdrv.c **** #endif
 585:usbdrv/usbdrv.c ****     }
 586:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 587:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 588:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 589:usbdrv/usbdrv.c ****         }
 590:usbdrv/usbdrv.c ****     }
 591:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 592:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 593:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 594:usbdrv/usbdrv.c ****             goto isNotReset;
 595:usbdrv/usbdrv.c ****     }
 596:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 597:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 598:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 599:usbdrv/usbdrv.c ****     usbResetStall();
 600:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 601:usbdrv/usbdrv.c **** isNotReset:
 602:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 603:usbdrv/usbdrv.c **** }
 604:usbdrv/usbdrv.c **** 
 605:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 606:usbdrv/usbdrv.c **** 
 607:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 608:usbdrv/usbdrv.c **** {
 102               		.stabn	68,0,609,.LM0-.LFBB1
 103               	.LM0:
 104               	.LFBB1:
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 609:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 610:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 107               		.stabn	68,0,611,.LM1-.LFBB1
 108               	.LM1:
 109 0000 AB9A      		sbi 53-32,3
 611:usbdrv/usbdrv.c **** #endif
 612:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 613:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 614:usbdrv/usbdrv.c **** #endif
 615:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 110               		.stabn	68,0,616,.LM2-.LFBB1
 111               	.LM2:
 112 0002 8BB7      		in r24,91-32
 113 0004 8062      		ori r24,lo8(32)
 114 0006 8BBF      		out 91-32,r24
 115               	.LBB61:
 116               	.LBB62:
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 117               		.stabn	68,0,200,.LM3-.LFBB1
 118               	.LM3:
 119 0008 8BE4      		ldi r24,lo8(75)
 120 000a 8093 0000 		sts usbTxStatus1+1,r24
 121               	.LBE62:
 122               	.LBE61:
 616:usbdrv/usbdrv.c ****     usbResetDataToggling();
 617:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
GAS LISTING /tmp/ccOpHXKC.s 			page 14


 618:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 123               		.stabn	68,0,619,.LM4-.LFBB1
 124               	.LM4:
 125 000e 8AE5      		ldi r24,lo8(90)
 126 0010 8093 0000 		sts usbTxStatus1,r24
 127               	/* epilogue start */
 619:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 620:usbdrv/usbdrv.c ****     usbTxLen3 = USBPID_NAK;
 621:usbdrv/usbdrv.c **** #endif
 622:usbdrv/usbdrv.c **** #endif
 623:usbdrv/usbdrv.c **** }
 128               		.stabn	68,0,624,.LM5-.LFBB1
 129               	.LM5:
 130 0014 0895      		ret
 131               		.size	usbInit, .-usbInit
 132               	.Lscope1:
 133               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 134               		.stabd	78,0,0
 135               		.stabs	"usbSetInterrupt:F(0,15)",36,0,246,usbSetInterrupt
 136               		.stabs	"data:P(0,16)=*(0,11)",64,0,245,26
 137               		.stabs	"len:P(0,11)",64,0,245,17
 138               	.global	usbSetInterrupt
 139               		.type	usbSetInterrupt, @function
 140               	usbSetInterrupt:
 141               		.stabd	46,0,0
 246:usbdrv/usbdrv.c **** {
 142               		.stabn	68,0,246,.LM6-.LFBB2
 143               	.LM6:
 144               	.LFBB2:
 145 0016 1F93      		push r17
 146               	/* prologue: function */
 147               	/* frame size = 0 */
 148 0018 DC01      		movw r26,r24
 149 001a 162F      		mov r17,r22
 150               	.LBB63:
 151               	.LBB64:
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 152               		.stabn	68,0,230,.LM7-.LFBB2
 153               	.LM7:
 154 001c 8091 0000 		lds r24,usbTxStatus1
 155 0020 84FF      		sbrs r24,4
 156 0022 00C0      		rjmp .L4
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 157               		.stabn	68,0,231,.LM8-.LFBB2
 158               	.LM8:
 159 0024 8091 0000 		lds r24,usbTxStatus1+1
 160 0028 98E8      		ldi r25,lo8(-120)
 161 002a 8927      		eor r24,r25
 162 002c 8093 0000 		sts usbTxStatus1+1,r24
 163 0030 00C0      		rjmp .L5
 164               	.L4:
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 165               		.stabn	68,0,233,.LM9-.LFBB2
 166               	.LM9:
 167 0032 8AE5      		ldi r24,lo8(90)
 168 0034 8093 0000 		sts usbTxStatus1,r24
 169               	.L5:
GAS LISTING /tmp/ccOpHXKC.s 			page 15


 170 0038 912F      		mov r25,r17
 171 003a E0E0      		ldi r30,lo8(usbTxStatus1+2)
 172 003c F0E0      		ldi r31,hi8(usbTxStatus1+2)
 173               	.L6:
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
 174               		.stabn	68,0,238,.LM10-.LFBB2
 175               	.LM10:
 176 003e 8D91      		ld r24,X+
 177 0040 8193      		st Z+,r24
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 178               		.stabn	68,0,239,.LM11-.LFBB2
 179               	.LM11:
 180 0042 9150      		subi r25,lo8(-(-1))
 181 0044 01F4      		brne .L6
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 182               		.stabn	68,0,240,.LM12-.LFBB2
 183               	.LM12:
 184 0046 80E0      		ldi r24,lo8(usbTxStatus1+2)
 185 0048 90E0      		ldi r25,hi8(usbTxStatus1+2)
 186 004a 612F      		mov r22,r17
 187 004c 00D0      		rcall usbCrc16Append
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 188               		.stabn	68,0,241,.LM13-.LFBB2
 189               	.LM13:
 190 004e 1C5F      		subi r17,lo8(-(4))
 191 0050 1093 0000 		sts usbTxStatus1,r17
 192               	/* epilogue start */
 193               	.LBE64:
 194               	.LBE63:
 248:usbdrv/usbdrv.c **** }
 195               		.stabn	68,0,248,.LM14-.LFBB2
 196               	.LM14:
 197 0054 1F91      		pop r17
 198 0056 0895      		ret
 199               		.size	usbSetInterrupt, .-usbSetInterrupt
 200               	.Lscope2:
 201               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 202               		.stabd	78,0,0
 203               		.stabs	"usbPoll:F(0,15)",36,0,567,usbPoll
 204               	.global	usbPoll
 205               		.type	usbPoll, @function
 206               	usbPoll:
 207               		.stabd	46,0,0
 567:usbdrv/usbdrv.c **** {
 208               		.stabn	68,0,567,.LM15-.LFBB3
 209               	.LM15:
 210               	.LFBB3:
 211 0058 1F93      		push r17
 212 005a CF93      		push r28
 213 005c DF93      		push r29
 214               	/* prologue: function */
 215               	/* frame size = 0 */
 571:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 216               		.stabn	68,0,571,.LM16-.LFBB3
 217               	.LM16:
 218 005e 6091 0000 		lds r22,usbRxLen
 219 0062 6350      		subi r22,lo8(-(-3))
GAS LISTING /tmp/ccOpHXKC.s 			page 16


 572:usbdrv/usbdrv.c ****     if(len >= 0){
 220               		.stabn	68,0,572,.LM17-.LFBB3
 221               	.LM17:
 222 0064 67FD      		sbrc r22,7
 223 0066 00C0      		rjmp .L10
 579:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 224               		.stabn	68,0,579,.LM18-.LFBB3
 225               	.LM18:
 226 0068 8091 0000 		lds r24,usbInputBufOffset
 227 006c CCE0      		ldi r28,lo8(12)
 228 006e D0E0      		ldi r29,hi8(12)
 229 0070 C81B      		sub r28,r24
 230 0072 D109      		sbc r29,__zero_reg__
 231 0074 C050      		subi r28,lo8(-(usbRxBuf))
 232 0076 D040      		sbci r29,hi8(-(usbRxBuf))
 233               	.LBB65:
 234               	.LBB66:
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 235               		.stabn	68,0,439,.LM19-.LFBB3
 236               	.LM19:
 237 0078 8091 0000 		lds r24,usbRxToken
 238 007c 8D32      		cpi r24,lo8(45)
 239 007e 01F0      		breq .+2
 240 0080 00C0      		rjmp .L11
 241               	.LBB68:
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 242               		.stabn	68,0,440,.LM20-.LFBB3
 243               	.LM20:
 244 0082 6830      		cpi r22,lo8(8)
 245 0084 01F0      		breq .+2
 246 0086 00C0      		rjmp .L12
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 247               		.stabn	68,0,443,.LM21-.LFBB3
 248               	.LM21:
 249 0088 83EC      		ldi r24,lo8(-61)
 250 008a 8093 0000 		sts usbTxBuf,r24
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 251               		.stabn	68,0,444,.LM22-.LFBB3
 252               	.LM22:
 253 008e 8AE5      		ldi r24,lo8(90)
 254 0090 8093 0000 		sts usbTxLen,r24
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 255               		.stabn	68,0,445,.LM23-.LFBB3
 256               	.LM23:
 257 0094 1092 0000 		sts usbMsgFlags,__zero_reg__
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 258               		.stabn	68,0,447,.LM24-.LFBB3
 259               	.LM24:
 260 0098 8881      		ld r24,Y
 261 009a 8076      		andi r24,lo8(96)
 262 009c 01F0      		breq .L13
 263               	.LBE68:
 264               	.LBE66:
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 265               		.stabn	68,0,448,.LM25-.LFBB3
 266               	.LM25:
 267 009e CE01      		movw r24,r28
GAS LISTING /tmp/ccOpHXKC.s 			page 17


 268 00a0 00D0      		rcall usbFunctionSetup
 269 00a2 282F      		mov r18,r24
 270               	.LBB80:
 271               	.LBB67:
 454:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 272               		.stabn	68,0,454,.LM26-.LFBB3
 273               	.LM26:
 274 00a4 8F3F      		cpi r24,lo8(-1)
 275 00a6 01F4      		brne .+2
 276 00a8 00C0      		rjmp .L14
 277 00aa 00C0      		rjmp .L15
 278               	.L13:
 279               	.LBB69:
 280               	.LBB70:
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 281               		.stabn	68,0,365,.LM27-.LFBB3
 282               	.LM27:
 283 00ac 9A81      		ldd r25,Y+2
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 284               		.stabn	68,0,370,.LM28-.LFBB3
 285               	.LM28:
 286 00ae 1092 0000 		sts usbTxBuf+9,__zero_reg__
 287               	.LBB71:
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 288               		.stabn	68,0,371,.LM29-.LFBB3
 289               	.LM29:
 290 00b2 8981      		ldd r24,Y+1
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 291               		.stabn	68,0,372,.LM30-.LFBB3
 292               	.LM30:
 293 00b4 8823      		tst r24
 294 00b6 01F4      		brne .L16
 295               	.LBB72:
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 296               		.stabn	68,0,380,.LM31-.LFBB3
 297               	.LM31:
 298 00b8 1092 0000 		sts usbTxBuf+10,__zero_reg__
 299 00bc 22E0      		ldi r18,lo8(2)
 300 00be 00C0      		rjmp .L53
 301               	.L16:
 302               	.LBE72:
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 303               		.stabn	68,0,389,.LM32-.LFBB3
 304               	.LM32:
 305 00c0 8530      		cpi r24,lo8(5)
 306 00c2 01F4      		brne .L18
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 307               		.stabn	68,0,390,.LM33-.LFBB3
 308               	.LM33:
 309 00c4 9093 0000 		sts usbNewDeviceAddr,r25
 310 00c8 00C0      		rjmp .L55
 311               	.L18:
 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 312               		.stabn	68,0,392,.LM34-.LFBB3
 313               	.LM34:
 314 00ca 8630      		cpi r24,lo8(6)
 315 00cc 01F4      		brne .L19
GAS LISTING /tmp/ccOpHXKC.s 			page 18


 316               	.LBB73:
 317               	.LBB74:
 318               	.LBB75:
 316:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 319               		.stabn	68,0,316,.LM35-.LFBB3
 320               	.LM35:
 321 00ce 8B81      		ldd r24,Y+3
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 322               		.stabn	68,0,317,.LM36-.LFBB3
 323               	.LM36:
 324 00d0 8130      		cpi r24,lo8(1)
 325 00d2 01F4      		brne .L20
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 326               		.stabn	68,0,318,.LM37-.LFBB3
 327               	.LM37:
 328 00d4 80E0      		ldi r24,lo8(usbDescriptorDevice)
 329 00d6 90E0      		ldi r25,hi8(usbDescriptorDevice)
 330 00d8 9093 0000 		sts (usbMsgPtr)+1,r25
 331 00dc 8093 0000 		sts usbMsgPtr,r24
 332 00e0 22E1      		ldi r18,lo8(18)
 333 00e2 00C0      		rjmp .L21
 334               	.L20:
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 335               		.stabn	68,0,319,.LM38-.LFBB3
 336               	.LM38:
 337 00e4 8230      		cpi r24,lo8(2)
 338 00e6 01F4      		brne .L22
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 339               		.stabn	68,0,320,.LM39-.LFBB3
 340               	.LM39:
 341 00e8 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 342 00ea 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 343 00ec 9093 0000 		sts (usbMsgPtr)+1,r25
 344 00f0 8093 0000 		sts usbMsgPtr,r24
 345 00f4 29E1      		ldi r18,lo8(25)
 346 00f6 00C0      		rjmp .L21
 347               	.L22:
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 348               		.stabn	68,0,321,.LM40-.LFBB3
 349               	.LM40:
 350 00f8 8330      		cpi r24,lo8(3)
 351 00fa 01F4      		brne .L23
 352               	.LBB76:
 327:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 353               		.stabn	68,0,327,.LM41-.LFBB3
 354               	.LM41:
 355 00fc 8A81      		ldd r24,Y+2
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 356               		.stabn	68,0,328,.LM42-.LFBB3
 357               	.LM42:
 358 00fe 8823      		tst r24
 359 0100 01F4      		brne .L24
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 360               		.stabn	68,0,329,.LM43-.LFBB3
 361               	.LM43:
 362 0102 80E0      		ldi r24,lo8(usbDescriptorString0)
 363 0104 90E0      		ldi r25,hi8(usbDescriptorString0)
GAS LISTING /tmp/ccOpHXKC.s 			page 19


 364 0106 9093 0000 		sts (usbMsgPtr)+1,r25
 365 010a 8093 0000 		sts usbMsgPtr,r24
 366 010e 24E0      		ldi r18,lo8(4)
 367 0110 00C0      		rjmp .L21
 368               	.L24:
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 369               		.stabn	68,0,330,.LM44-.LFBB3
 370               	.LM44:
 371 0112 8130      		cpi r24,lo8(1)
 372 0114 01F0      		breq .L23
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 373               		.stabn	68,0,332,.LM45-.LFBB3
 374               	.LM45:
 375 0116 8230      		cpi r24,lo8(2)
 376 0118 01F4      		brne .L23
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 377               		.stabn	68,0,333,.LM46-.LFBB3
 378               	.LM46:
 379 011a 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 380 011c 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 381 011e 9093 0000 		sts (usbMsgPtr)+1,r25
 382 0122 8093 0000 		sts usbMsgPtr,r24
 383 0126 26E1      		ldi r18,lo8(22)
 384 0128 00C0      		rjmp .L21
 385               	.L23:
 386 012a 20E0      		ldi r18,lo8(0)
 387               	.L21:
 388               	.LBE76:
 389               	.LBE75:
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 390               		.stabn	68,0,353,.LM47-.LFBB3
 391               	.LM47:
 392 012c 80E4      		ldi r24,lo8(64)
 393 012e 8093 0000 		sts usbMsgFlags,r24
 394 0132 00C0      		rjmp .L15
 395               	.L19:
 396               	.LBE74:
 397               	.LBE73:
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 398               		.stabn	68,0,395,.LM48-.LFBB3
 399               	.LM48:
 400 0134 8830      		cpi r24,lo8(8)
 401 0136 01F4      		brne .L25
 402 0138 21E0      		ldi r18,lo8(1)
 403 013a 80E0      		ldi r24,lo8(usbConfiguration)
 404 013c 90E0      		ldi r25,hi8(usbConfiguration)
 405 013e 00C0      		rjmp .L17
 406               	.L25:
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 407               		.stabn	68,0,398,.LM49-.LFBB3
 408               	.LM49:
 409 0140 8930      		cpi r24,lo8(9)
 410 0142 01F4      		brne .L26
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 411               		.stabn	68,0,399,.LM50-.LFBB3
 412               	.LM50:
 413 0144 9093 0000 		sts usbConfiguration,r25
GAS LISTING /tmp/ccOpHXKC.s 			page 20


 414 0148 00C0      		rjmp .L55
 415               	.L26:
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 416               		.stabn	68,0,401,.LM51-.LFBB3
 417               	.LM51:
 418 014a 8A30      		cpi r24,lo8(10)
 419 014c 01F4      		brne .L27
 420 014e 21E0      		ldi r18,lo8(1)
 421 0150 00C0      		rjmp .L53
 422               	.L27:
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 423               		.stabn	68,0,404,.LM52-.LFBB3
 424               	.LM52:
 425 0152 8B30      		cpi r24,lo8(11)
 426 0154 01F4      		brne .L55
 427               	.L28:
 428               	.LBB77:
 429               	.LBB78:
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 430               		.stabn	68,0,200,.LM53-.LFBB3
 431               	.LM53:
 432 0156 8BE4      		ldi r24,lo8(75)
 433 0158 8093 0000 		sts usbTxStatus1+1,r24
 434               	.L55:
 435 015c 20E0      		ldi r18,lo8(0)
 436               	.L53:
 437 015e 80E0      		ldi r24,lo8(usbTxBuf+9)
 438 0160 90E0      		ldi r25,hi8(usbTxBuf+9)
 439               	.L17:
 440               	.LBE78:
 441               	.LBE77:
 442               	.LBE71:
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 443               		.stabn	68,0,411,.LM54-.LFBB3
 444               	.LM54:
 445 0162 9093 0000 		sts (usbMsgPtr)+1,r25
 446 0166 8093 0000 		sts usbMsgPtr,r24
 447 016a 00C0      		rjmp .L15
 448               	.L14:
 449               	.LBE70:
 450               	.LBE69:
 456:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 451               		.stabn	68,0,456,.LM55-.LFBB3
 452               	.LM55:
 453 016c 8881      		ld r24,Y
 454 016e 87FD      		sbrc r24,7
 458:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 455               		.stabn	68,0,458,.LM56-.LFBB3
 456               	.LM56:
 457 0170 2E81      		ldd r18,Y+6
 458               	.L29:
 463:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 459               		.stabn	68,0,463,.LM57-.LFBB3
 460               	.LM57:
 461 0172 80E8      		ldi r24,lo8(-128)
 462 0174 8093 0000 		sts usbMsgFlags,r24
 463 0178 00C0      		rjmp .L31
GAS LISTING /tmp/ccOpHXKC.s 			page 21


 464               	.L15:
 467:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 465               		.stabn	68,0,467,.LM58-.LFBB3
 466               	.LM58:
 467 017a 8F81      		ldd r24,Y+7
 468 017c 8823      		tst r24
 469 017e 01F4      		brne .L31
 470 0180 8E81      		ldd r24,Y+6
 471 0182 8217      		cp r24,r18
 472 0184 00F0      		brlo .L30
 473               	.L31:
 474 0186 822F      		mov r24,r18
 475               	.L30:
 473:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 476               		.stabn	68,0,473,.LM59-.LFBB3
 477               	.LM59:
 478 0188 8093 0000 		sts usbMsgLen,r24
 479 018c 00C0      		rjmp .L12
 480               	.L11:
 481               	.LBE67:
 476:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 482               		.stabn	68,0,476,.LM60-.LFBB3
 483               	.LM60:
 484 018e 8091 0000 		lds r24,usbMsgFlags
 485 0192 87FF      		sbrs r24,7
 486 0194 00C0      		rjmp .L12
 487               	.LBE80:
 477:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 488               		.stabn	68,0,477,.LM61-.LFBB3
 489               	.LM61:
 490 0196 CE01      		movw r24,r28
 491 0198 00D0      		rcall usbFunctionWrite
 492               	.LBB81:
 493               	.LBB79:
 478:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 494               		.stabn	68,0,478,.LM62-.LFBB3
 495               	.LM62:
 496 019a 8F3F      		cpi r24,lo8(-1)
 497 019c 01F4      		brne .L32
 479:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 498               		.stabn	68,0,479,.LM63-.LFBB3
 499               	.LM63:
 500 019e 8EE1      		ldi r24,lo8(30)
 501 01a0 8093 0000 		sts usbTxLen,r24
 502 01a4 00C0      		rjmp .L12
 503               	.L32:
 480:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 504               		.stabn	68,0,480,.LM64-.LFBB3
 505               	.LM64:
 506 01a6 8823      		tst r24
 507 01a8 01F0      		breq .L12
 481:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 508               		.stabn	68,0,481,.LM65-.LFBB3
 509               	.LM65:
 510 01aa 1092 0000 		sts usbMsgLen,__zero_reg__
 511               	.L12:
 512               	.LBE79:
GAS LISTING /tmp/ccOpHXKC.s 			page 22


 513               	.LBE81:
 514               	.LBE65:
 584:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 515               		.stabn	68,0,584,.LM66-.LFBB3
 516               	.LM66:
 517 01ae 1092 0000 		sts usbRxLen,__zero_reg__
 518               	.L10:
 587:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 519               		.stabn	68,0,587,.LM67-.LFBB3
 520               	.LM67:
 521 01b2 8091 0000 		lds r24,usbTxLen
 522 01b6 84FF      		sbrs r24,4
 523 01b8 00C0      		rjmp .L33
 588:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 524               		.stabn	68,0,588,.LM68-.LFBB3
 525               	.LM68:
 526 01ba 8091 0000 		lds r24,usbMsgLen
 527 01be 8F3F      		cpi r24,lo8(-1)
 528 01c0 01F4      		brne .+2
 529 01c2 00C0      		rjmp .L33
 530 01c4 182F      		mov r17,r24
 531 01c6 8930      		cpi r24,lo8(9)
 532 01c8 00F0      		brlo .L34
 533 01ca 18E0      		ldi r17,lo8(8)
 534               	.L34:
 535               	.LBB82:
 536               	.LBB83:
 533:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 537               		.stabn	68,0,533,.LM69-.LFBB3
 538               	.LM69:
 539 01cc 811B      		sub r24,r17
 540 01ce 8093 0000 		sts usbMsgLen,r24
 534:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 541               		.stabn	68,0,534,.LM70-.LFBB3
 542               	.LM70:
 543 01d2 8091 0000 		lds r24,usbTxBuf
 544 01d6 98E8      		ldi r25,lo8(-120)
 545 01d8 8927      		eor r24,r25
 546 01da 8093 0000 		sts usbTxBuf,r24
 547               	.LBB84:
 548               	.LBB85:
 495:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 549               		.stabn	68,0,495,.LM71-.LFBB3
 550               	.LM71:
 551 01de 1123      		tst r17
 552 01e0 01F0      		breq .L35
 497:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 553               		.stabn	68,0,497,.LM72-.LFBB3
 554               	.LM72:
 555 01e2 8091 0000 		lds r24,usbMsgFlags
 556 01e6 87FF      		sbrs r24,7
 557 01e8 00C0      		rjmp .L36
 558               	.LBE85:
 498:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 559               		.stabn	68,0,498,.LM73-.LFBB3
 560               	.LM73:
 561 01ea 80E0      		ldi r24,lo8(usbTxBuf+1)
GAS LISTING /tmp/ccOpHXKC.s 			page 23


 562 01ec 90E0      		ldi r25,hi8(usbTxBuf+1)
 563 01ee 612F      		mov r22,r17
 564 01f0 00D0      		rcall usbFunctionRead
 565 01f2 182F      		mov r17,r24
 566               	.LBE84:
 536:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 567               		.stabn	68,0,536,.LM74-.LFBB3
 568               	.LM74:
 569 01f4 8930      		cpi r24,lo8(9)
 570 01f6 00F4      		brsh .L52
 571 01f8 00C0      		rjmp .L35
 572               	.L36:
 573               	.LBB90:
 574               	.LBB89:
 575               	.LBB86:
 502:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 576               		.stabn	68,0,502,.LM75-.LFBB3
 577               	.LM75:
 578 01fa 2091 0000 		lds r18,usbMsgPtr
 579 01fe 3091 0000 		lds r19,(usbMsgPtr)+1
 503:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 580               		.stabn	68,0,503,.LM76-.LFBB3
 581               	.LM76:
 582 0202 86FF      		sbrs r24,6
 583 0204 00C0      		rjmp .L38
 584 0206 A0E0      		ldi r26,lo8(usbTxBuf+1)
 585 0208 B0E0      		ldi r27,hi8(usbTxBuf+1)
 586 020a 80E0      		ldi r24,lo8(0)
 587 020c 90E0      		ldi r25,hi8(0)
 588               	.L39:
 589               	.LBB87:
 590               	.LBB88:
 505:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 591               		.stabn	68,0,505,.LM77-.LFBB3
 592               	.LM77:
 593 020e F901      		movw r30,r18
 594 0210 E80F      		add r30,r24
 595 0212 F91F      		adc r31,r25
 596               	/* #APP */
 597               	 ;  505 "usbdrv/usbdrv.c" 1
 598 0214 E491      		lpm r30, Z
 599               		
 600               	 ;  0 "" 2
 601               	/* #NOAPP */
 602               	.LBE88:
 506:usbdrv/usbdrv.c ****                     *data++ = c;
 603               		.stabn	68,0,506,.LM78-.LFBB3
 604               	.LM78:
 605 0216 ED93      		st X+,r30
 606 0218 0196      		adiw r24,1
 607               	.LBE87:
 508:usbdrv/usbdrv.c ****                 }while(--i);
 608               		.stabn	68,0,508,.LM79-.LFBB3
 609               	.LM79:
 610 021a 1817      		cp r17,r24
 611 021c 01F4      		brne .L39
 612 021e 00C0      		rjmp .L54
GAS LISTING /tmp/ccOpHXKC.s 			page 24


 613               	.L38:
 614 0220 912F      		mov r25,r17
 615 0222 D901      		movw r26,r18
 616 0224 E0E0      		ldi r30,lo8(usbTxBuf+1)
 617 0226 F0E0      		ldi r31,hi8(usbTxBuf+1)
 618               	.L41:
 511:usbdrv/usbdrv.c ****                     *data++ = *r++;
 619               		.stabn	68,0,511,.LM80-.LFBB3
 620               	.LM80:
 621 0228 8D91      		ld r24,X+
 622 022a 8193      		st Z+,r24
 512:usbdrv/usbdrv.c ****                 }while(--i);
 623               		.stabn	68,0,512,.LM81-.LFBB3
 624               	.LM81:
 625 022c 9150      		subi r25,lo8(-(-1))
 626 022e 01F4      		brne .L41
 627               	.L54:
 628 0230 1150      		subi r17,lo8(-(-1))
 629 0232 812F      		mov r24,r17
 630 0234 90E0      		ldi r25,lo8(0)
 631 0236 1F5F      		subi r17,lo8(-(1))
 632 0238 0196      		adiw r24,1
 633 023a 820F      		add r24,r18
 634 023c 931F      		adc r25,r19
 514:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 635               		.stabn	68,0,514,.LM82-.LFBB3
 636               	.LM82:
 637 023e 9093 0000 		sts (usbMsgPtr)+1,r25
 638 0242 8093 0000 		sts usbMsgPtr,r24
 639               	.L35:
 640               	.LBE86:
 641               	.LBE89:
 642               	.LBE90:
 537:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 643               		.stabn	68,0,537,.LM83-.LFBB3
 644               	.LM83:
 645 0246 80E0      		ldi r24,lo8(usbTxBuf+1)
 646 0248 90E0      		ldi r25,hi8(usbTxBuf+1)
 647 024a 612F      		mov r22,r17
 648 024c 00D0      		rcall usbCrc16Append
 538:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 649               		.stabn	68,0,538,.LM84-.LFBB3
 650               	.LM84:
 651 024e 612F      		mov r22,r17
 652 0250 6C5F      		subi r22,lo8(-(4))
 539:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 653               		.stabn	68,0,539,.LM85-.LFBB3
 654               	.LM85:
 655 0252 6C30      		cpi r22,lo8(12)
 656 0254 01F0      		breq .L42
 540:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 657               		.stabn	68,0,540,.LM86-.LFBB3
 658               	.LM86:
 659 0256 8FEF      		ldi r24,lo8(-1)
 660 0258 8093 0000 		sts usbMsgLen,r24
 661 025c 00C0      		rjmp .L42
 662               	.L52:
GAS LISTING /tmp/ccOpHXKC.s 			page 25


 543:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 663               		.stabn	68,0,543,.LM87-.LFBB3
 664               	.LM87:
 665 025e 8FEF      		ldi r24,lo8(-1)
 666 0260 8093 0000 		sts usbMsgLen,r24
 667 0264 6EE1      		ldi r22,lo8(30)
 668               	.L42:
 545:usbdrv/usbdrv.c ****     usbTxLen = len;
 669               		.stabn	68,0,545,.LM88-.LFBB3
 670               	.LM88:
 671 0266 6093 0000 		sts usbTxLen,r22
 672               	.L33:
 673 026a 94E1      		ldi r25,lo8(20)
 674               	.L44:
 675               	.LBE83:
 676               	.LBE82:
 677               	.LBB91:
 593:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 678               		.stabn	68,0,593,.LM89-.LFBB3
 679               	.LM89:
 680 026c 86B3      		in r24,54-32
 594:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 681               		.stabn	68,0,594,.LM90-.LFBB3
 682               	.LM90:
 683 026e 8871      		andi r24,lo8(24)
 684 0270 01F4      		brne .L43
 685               	.LBE91:
 592:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 686               		.stabn	68,0,592,.LM91-.LFBB3
 687               	.LM91:
 688 0272 9150      		subi r25,lo8(-(-1))
 689 0274 01F4      		brne .L44
 598:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 690               		.stabn	68,0,598,.LM92-.LFBB3
 691               	.LM92:
 692 0276 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 599:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 693               		.stabn	68,0,599,.LM93-.LFBB3
 694               	.LM93:
 695 027a 1092 0000 		sts usbDeviceAddr,__zero_reg__
 696               	.L43:
 697               	.LBB92:
 698               	.LBB93:
 555:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 699               		.stabn	68,0,555,.LM94-.LFBB3
 700               	.LM94:
 701 027e 10E0      		ldi r17,lo8(0)
 702 0280 9923      		tst r25
 703 0282 01F4      		brne .L45
 704 0284 11E0      		ldi r17,lo8(1)
 705               	.L45:
 557:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 706               		.stabn	68,0,557,.LM95-.LFBB3
 707               	.LM95:
 708 0286 8091 0000 		lds r24,wasReset.1507
 709 028a 8117      		cp r24,r17
 710 028c 01F0      		breq .L48
GAS LISTING /tmp/ccOpHXKC.s 			page 26


 558:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 711               		.stabn	68,0,558,.LM96-.LFBB3
 712               	.LM96:
 713 028e 1123      		tst r17
 714 0290 01F4      		brne .L47
 715 0292 00D0      		rcall usbEventResetReady
 716               	.L47:
 559:usbdrv/usbdrv.c ****         wasReset = isReset;
 717               		.stabn	68,0,559,.LM97-.LFBB3
 718               	.LM97:
 719 0294 1093 0000 		sts wasReset.1507,r17
 720               	.L48:
 721               	/* epilogue start */
 722               	.LBE93:
 723               	.LBE92:
 604:usbdrv/usbdrv.c **** }
 724               		.stabn	68,0,604,.LM98-.LFBB3
 725               	.LM98:
 726 0298 DF91      		pop r29
 727 029a CF91      		pop r28
 728 029c 1F91      		pop r17
 729 029e 0895      		ret
 730               		.size	usbPoll, .-usbPoll
 731               		.stabs	"i:r(0,11)",64,0,569,25
 732               		.stabn	192,0,0,.LFBB3-.LFBB3
 733               		.stabs	"replyLen:r(0,11)",64,0,442,18
 734               		.stabn	192,0,0,.LBB67-.LFBB3
 735               		.stabn	224,0,0,.LBE67-.LFBB3
 736               		.stabs	"replyLen:r(0,11)",64,0,442,18
 737               		.stabn	192,0,0,.LBB68-.LFBB3
 738               		.stabs	"dataPtr:r(0,16)",64,0,364,24
 739               		.stabs	"value:r(0,11)",64,0,365,25
 740               		.stabn	192,0,0,.LBB70-.LFBB3
 741               		.stabs	"_cmd:r(0,11)",64,0,371,24
 742               		.stabn	192,0,0,.LBB71-.LFBB3
 743               		.stabs	"_cmd:r(0,11)",64,0,316,24
 744               		.stabn	192,0,0,.LBB75-.LFBB3
 745               		.stabs	"_cmd:r(0,11)",64,0,327,24
 746               		.stabn	192,0,0,.LBB76-.LFBB3
 747               		.stabn	224,0,0,.LBE76-.LFBB3
 748               		.stabn	224,0,0,.LBE75-.LFBB3
 749               		.stabn	224,0,0,.LBE71-.LFBB3
 750               		.stabn	224,0,0,.LBE70-.LFBB3
 751               		.stabn	224,0,0,.LBE68-.LFBB3
 752               		.stabs	"rval:r(0,11)",64,0,477,24
 753               		.stabn	192,0,0,.LBB79-.LFBB3
 754               		.stabn	224,0,0,.LBE79-.LFBB3
 755               		.stabs	"len:r(0,11)",64,0,528,17
 756               		.stabn	192,0,0,.LBB83-.LFBB3
 757               		.stabs	"data:r(0,16)",64,0,535,26
 758               		.stabn	192,0,0,.LBB84-.LFBB3
 759               		.stabs	"r:r(0,16)",64,0,502,18
 760               		.stabn	192,0,0,.LBB86-.LFBB3
 761               		.stabs	"__result:r(5,2)",64,0,505,30
 762               		.stabn	192,0,0,.LBB88-.LFBB3
 763               		.stabn	224,0,0,.LBE88-.LFBB3
 764               		.stabn	224,0,0,.LBE86-.LFBB3
GAS LISTING /tmp/ccOpHXKC.s 			page 27


 765               		.stabn	224,0,0,.LBE84-.LFBB3
 766               		.stabs	"data:r(0,16)",64,0,535,26
 767               		.stabn	192,0,0,.LBB90-.LFBB3
 768               		.stabn	224,0,0,.LBE90-.LFBB3
 769               		.stabn	224,0,0,.LBE83-.LFBB3
 770               		.stabs	"isReset:r(0,11)",64,0,555,17
 771               		.stabn	192,0,0,.LBB93-.LFBB3
 772               		.stabn	224,0,0,.LBE93-.LFBB3
 773               		.stabn	224,0,0,.Lscope3-.LFBB3
 774               	.Lscope3:
 775               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 776               		.stabd	78,0,0
 777               	.global	usbTxLen
 778               		.data
 779               		.type	usbTxLen, @object
 780               		.size	usbTxLen, 1
 781               	usbTxLen:
 782 0000 5A        		.byte	90
 783               	.global	usbDescriptorString0
 784               		.section	.progmem.data,"a",@progbits
 785               		.type	usbDescriptorString0, @object
 786               		.size	usbDescriptorString0, 4
 787               	usbDescriptorString0:
 788 0000 04        		.byte	4
 789 0001 03        		.byte	3
 790 0002 09        		.byte	9
 791 0003 04        		.byte	4
 792               	.global	usbDescriptorStringDevice
 793               		.type	usbDescriptorStringDevice, @object
 794               		.size	usbDescriptorStringDevice, 22
 795               	usbDescriptorStringDevice:
 796 0004 1603      		.word	790
 797 0006 5500      		.word	85
 798 0008 5300      		.word	83
 799 000a 4200      		.word	66
 800 000c 7400      		.word	116
 801 000e 6900      		.word	105
 802 0010 6E00      		.word	110
 803 0012 7900      		.word	121
 804 0014 5300      		.word	83
 805 0016 5000      		.word	80
 806 0018 4900      		.word	73
 807               	.global	usbDescriptorDevice
 808               		.type	usbDescriptorDevice, @object
 809               		.size	usbDescriptorDevice, 18
 810               	usbDescriptorDevice:
 811 001a 12        		.byte	18
 812 001b 01        		.byte	1
 813 001c 10        		.byte	16
 814 001d 01        		.byte	1
 815 001e 00        		.byte	0
 816 001f 00        		.byte	0
 817 0020 00        		.byte	0
 818 0021 08        		.byte	8
 819 0022 81        		.byte	-127
 820 0023 17        		.byte	23
 821 0024 9F        		.byte	-97
GAS LISTING /tmp/ccOpHXKC.s 			page 28


 822 0025 0C        		.byte	12
 823 0026 04        		.byte	4
 824 0027 01        		.byte	1
 825 0028 00        		.byte	0
 826 0029 02        		.byte	2
 827 002a 00        		.byte	0
 828 002b 01        		.byte	1
 829               	.global	usbDescriptorConfiguration
 830               		.type	usbDescriptorConfiguration, @object
 831               		.size	usbDescriptorConfiguration, 25
 832               	usbDescriptorConfiguration:
 833 002c 09        		.byte	9
 834 002d 02        		.byte	2
 835 002e 19        		.byte	25
 836 002f 00        		.byte	0
 837 0030 01        		.byte	1
 838 0031 01        		.byte	1
 839 0032 00        		.byte	0
 840 0033 80        		.byte	-128
 841 0034 64        		.byte	100
 842 0035 09        		.byte	9
 843 0036 04        		.byte	4
 844 0037 00        		.byte	0
 845 0038 00        		.byte	0
 846 0039 01        		.byte	1
 847 003a FF        		.byte	-1
 848 003b 00        		.byte	0
 849 003c 00        		.byte	0
 850 003d 00        		.byte	0
 851 003e 07        		.byte	7
 852 003f 05        		.byte	5
 853 0040 81        		.byte	-127
 854 0041 03        		.byte	3
 855 0042 08        		.byte	8
 856 0043 00        		.byte	0
 857 0044 0A        		.byte	10
 858               		.data
 859               		.type	usbMsgLen, @object
 860               		.size	usbMsgLen, 1
 861               	usbMsgLen:
 862 0001 FF        		.byte	-1
 863               		.lcomm wasReset.1507,1
 864               		.lcomm usbMsgFlags,1
 865               		.comm usbMsgPtr,2,1
 866               		.comm usbRxToken,1,1
 867               		.comm usbConfiguration,1,1
 868               		.comm usbTxStatus1,12,1
 869               		.comm usbRxBuf,22,1
 870               		.comm usbInputBufOffset,1,1
 871               		.comm usbDeviceAddr,1,1
 872               		.comm usbNewDeviceAddr,1,1
 873               		.comm usbRxLen,1,1
 874               		.comm usbCurrentTok,1,1
 875               		.comm usbTxBuf,11,1
 876               		.stabs	"wasReset:V(0,11)",40,0,554,wasReset.1507
 877               		.stabs	"usbMsgLen:S(0,11)",38,0,49,usbMsgLen
 878               		.stabs	"usbMsgFlags:S(0,11)",40,0,50,usbMsgFlags
GAS LISTING /tmp/ccOpHXKC.s 			page 29


 879               		.stabs	"usbMsgPtr:G(0,16)",32,0,48,0
 880               		.stabs	"usbRxToken:G(0,11)",32,0,31,0
 881               		.stabs	"usbConfiguration:G(0,11)",32,0,28,0
 882               		.stabs	"usbDescriptorDevice:G(0,17)=ar(9,4);0;17;(0,2)",32,0,111,0
 883               		.stabs	"usbDescriptorConfiguration:G(0,18)=ar(9,4);0;24;(0,2)",32,0,142,0
 884               		.stabs	"usbDescriptorString0:G(0,19)=ar(9,4);0;3;(0,2)",32,0,70,0
 885               		.stabs	"usbDescriptorStringDevice:G(0,20)=ar(9,4);0;10;(0,1)",32,0,89,0
 886               		.stabs	"usbTxStatus1:G(9,5)",32,0,38,0
 887               		.stabs	"usbRxBuf:G(0,21)=ar(9,4);0;21;(0,11)",32,0,24,0
 888               		.stabs	"usbInputBufOffset:G(0,11)",32,0,25,0
 889               		.stabs	"usbDeviceAddr:G(0,11)",32,0,26,0
 890               		.stabs	"usbNewDeviceAddr:G(0,11)",32,0,27,0
 891               		.stabs	"usbRxLen:G(0,22)=B(0,10)",32,0,29,0
 892               		.stabs	"usbCurrentTok:G(0,11)",32,0,30,0
 893               		.stabs	"usbTxLen:G(9,2)",32,0,32,0
 894               		.stabs	"usbTxBuf:G(9,3)",32,0,33,0
 895               		.text
 896               		.stabs	"",100,0,0,.Letext0
 897               	.Letext0:
GAS LISTING /tmp/ccOpHXKC.s 			page 30


DEFINED SYMBOLS
                            *ABS*:0000000000000000 usbdrv.c
     /tmp/ccOpHXKC.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccOpHXKC.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccOpHXKC.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccOpHXKC.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/ccOpHXKC.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccOpHXKC.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccOpHXKC.s:100    .text:0000000000000000 usbInit
                            *COM*:000000000000000c usbTxStatus1
     /tmp/ccOpHXKC.s:140    .text:0000000000000016 usbSetInterrupt
     /tmp/ccOpHXKC.s:206    .text:0000000000000058 usbPoll
                            *COM*:0000000000000001 usbRxLen
                            *COM*:0000000000000001 usbInputBufOffset
                            *COM*:0000000000000016 usbRxBuf
                            *COM*:0000000000000001 usbRxToken
                            *COM*:000000000000000b usbTxBuf
     /tmp/ccOpHXKC.s:781    .data:0000000000000000 usbTxLen
     /tmp/ccOpHXKC.s:863    .bss:0000000000000001 usbMsgFlags
                            *COM*:0000000000000001 usbNewDeviceAddr
     /tmp/ccOpHXKC.s:810    .progmem.data:000000000000001a usbDescriptorDevice
                            *COM*:0000000000000002 usbMsgPtr
     /tmp/ccOpHXKC.s:832    .progmem.data:000000000000002c usbDescriptorConfiguration
     /tmp/ccOpHXKC.s:787    .progmem.data:0000000000000000 usbDescriptorString0
     /tmp/ccOpHXKC.s:795    .progmem.data:0000000000000004 usbDescriptorStringDevice
                            *COM*:0000000000000001 usbConfiguration
     /tmp/ccOpHXKC.s:861    .data:0000000000000001 usbMsgLen
                            *COM*:0000000000000001 usbDeviceAddr
                             .bss:0000000000000000 wasReset.1507
                            *COM*:0000000000000001 usbCurrentTok

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
usbCrc16Append
usbFunctionSetup
usbFunctionWrite
usbFunctionRead
usbEventResetReady
