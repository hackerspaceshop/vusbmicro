GAS LISTING /tmp/ccZgsOoQ.s 			page 1


   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.stabs	"/home/overflo/projects/vusbtiny/firmware/vusbtiny/",100,0,2,.Ltext0
  11               		.stabs	"main.c",100,0,2,.Ltext0
  12               		.text
  13               	.Ltext0:
  14               		.stabs	"gcc2_compiled.",60,0,0,0
  15               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,1,0
  16               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,1,0
  17               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,1,0
  18               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,1,0
  19               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,1,0
  20               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,1,
  21               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,1,0
  22               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,1,0
  23               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,1,0
  24               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,1,0
  25               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,1,0
  26               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,1,0
  27               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,1,0
  28               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,1,0
  29               		.stabs	"void:t(0,15)=(0,15)",128,0,1,0
  30               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/io.h",130,0,0,0
  31               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/sfr_defs.h",130,0,0,0
  32               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/inttypes.h",130,0,0,0
  33               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdint.h",130,0,0,0
  34               		.stabs	"int8_t:t(4,1)=(0,10)",128,0,121,0
  35               		.stabs	"uint8_t:t(4,2)=(0,11)",128,0,122,0
  36               		.stabs	"int16_t:t(4,3)=(0,1)",128,0,123,0
  37               		.stabs	"uint16_t:t(4,4)=(0,4)",128,0,124,0
  38               		.stabs	"int32_t:t(4,5)=(0,3)",128,0,125,0
  39               		.stabs	"uint32_t:t(4,6)=(0,5)",128,0,126,0
  40               		.stabs	"int64_t:t(4,7)=(0,6)",128,0,128,0
  41               		.stabs	"uint64_t:t(4,8)=(0,7)",128,0,129,0
  42               		.stabs	"intptr_t:t(4,9)=(4,3)",128,0,142,0
  43               		.stabs	"uintptr_t:t(4,10)=(4,4)",128,0,147,0
  44               		.stabs	"int_least8_t:t(4,11)=(4,1)",128,0,159,0
  45               		.stabs	"uint_least8_t:t(4,12)=(4,2)",128,0,164,0
  46               		.stabs	"int_least16_t:t(4,13)=(4,3)",128,0,169,0
  47               		.stabs	"uint_least16_t:t(4,14)=(4,4)",128,0,174,0
  48               		.stabs	"int_least32_t:t(4,15)=(4,5)",128,0,179,0
  49               		.stabs	"uint_least32_t:t(4,16)=(4,6)",128,0,184,0
  50               		.stabs	"int_least64_t:t(4,17)=(4,7)",128,0,192,0
  51               		.stabs	"uint_least64_t:t(4,18)=(4,8)",128,0,199,0
  52               		.stabs	"int_fast8_t:t(4,19)=(4,1)",128,0,213,0
  53               		.stabs	"uint_fast8_t:t(4,20)=(4,2)",128,0,218,0
  54               		.stabs	"int_fast16_t:t(4,21)=(4,3)",128,0,223,0
  55               		.stabs	"uint_fast16_t:t(4,22)=(4,4)",128,0,228,0
  56               		.stabs	"int_fast32_t:t(4,23)=(4,5)",128,0,233,0
  57               		.stabs	"uint_fast32_t:t(4,24)=(4,6)",128,0,238,0
GAS LISTING /tmp/ccZgsOoQ.s 			page 2


  58               		.stabs	"int_fast64_t:t(4,25)=(4,7)",128,0,246,0
  59               		.stabs	"uint_fast64_t:t(4,26)=(4,8)",128,0,253,0
  60               		.stabs	"intmax_t:t(4,27)=(4,7)",128,0,273,0
  61               		.stabs	"uintmax_t:t(4,28)=(4,8)",128,0,278,0
  62               		.stabn	162,0,0,0
  63               		.stabs	"int_farptr_t:t(3,1)=(4,5)",128,0,77,0
  64               		.stabs	"uint_farptr_t:t(3,2)=(4,6)",128,0,81,0
  65               		.stabn	162,0,0,0
  66               		.stabn	162,0,0,0
  67               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/fuse.h",130,0,0,0
  68               		.stabs	"__fuse_t:t(5,1)=(5,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,239,0
  69               		.stabn	162,0,0,0
  70               		.stabn	162,0,0,0
  71               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/eeprom.h",130,0,0,0
  72               		.stabs	"/usr/lib/gcc/avr/4.3.4/include/stddef.h",130,0,0,0
  73               		.stabs	"ptrdiff_t:t(7,1)=(0,1)",128,0,152,0
  74               		.stabs	"size_t:t(7,2)=(0,4)",128,0,214,0
  75               		.stabs	"wchar_t:t(7,3)=(0,1)",128,0,326,0
  76               		.stabn	162,0,0,0
  77               		.stabn	162,0,0,0
  78               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/avr/pgmspace.h",130,0,0,0
  79               		.stabs	"prog_void:t(8,1)=(8,2)=(8,2)",128,0,211,0
  80               		.stabs	"prog_char:t(8,3)=(8,4)=@s8;r(8,4);0;255;",128,0,212,0
  81               		.stabs	"prog_uchar:t(8,5)=(8,4)",128,0,213,0
  82               		.stabs	"prog_int8_t:t(8,6)=(8,7)=(0,10)",128,0,215,0
  83               		.stabs	"prog_uint8_t:t(8,8)=(8,4)",128,0,216,0
  84               		.stabs	"prog_int16_t:t(8,9)=(8,10)=(0,1)",128,0,217,0
  85               		.stabs	"prog_uint16_t:t(8,11)=(8,12)=(0,4)",128,0,218,0
  86               		.stabs	"prog_int32_t:t(8,13)=(8,14)=(0,3)",128,0,219,0
  87               		.stabs	"prog_uint32_t:t(8,15)=(8,16)=(0,5)",128,0,220,0
  88               		.stabs	"prog_int64_t:t(8,17)=(8,18)=(0,6)",128,0,222,0
  89               		.stabs	"prog_uint64_t:t(8,19)=(8,20)=(0,7)",128,0,223,0
  90               		.stabn	162,0,0,0
  91               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/stdlib.h",130,0,0,0
  92               		.stabs	"div_t:t(9,1)=(9,2)=s4quot:(0,1),0,16;rem:(0,1),16,16;;",128,0,71,0
  93               		.stabs	"ldiv_t:t(9,3)=(9,4)=s8quot:(0,3),0,32;rem:(0,3),32,32;;",128,0,77,0
  94               		.stabs	"__compar_fn_t:t(9,5)=(9,6)=*(9,7)=f(0,1)",128,0,80,0
  95               		.stabn	162,0,0,0
  96               		.stabs	"usbdrv/usbdrv.h",130,0,0,0
  97               		.stabs	"usbTxStatus:T(10,1)=s12len:(10,2)=B(0,11),0,8;buffer:(10,3)=ar(10,4)=r(10,4);0;0177777;;0;
  98               		.stabs	"usbTxStatus_t:t(10,5)=(10,1)",128,0,650,0
  99               		.stabs	"usbWord:T(10,6)=u2word:(0,4),0,16;bytes:(10,7)=ar(10,4);0;1;(0,11),0,16;;",128,0,0,0
 100               		.stabs	"usbWord_t:t(10,8)=(10,6)",128,0,662,0
 101               		.stabs	"usbRequest:T(10,9)=s8bmRequestType:(0,11),0,8;bRequest:(0,11),8,8;wValue:(10,8),16,16;wInd
 102               		.stabs	"usbRequest_t:t(10,10)=(10,9)",128,0,670,0
 103               		.stabn	162,0,0,0
 104               		.stabs	" :T(0,16)=@s8;eUSBTINY_ECHO:0,USBTINY_READ:1,USBTINY_WRITE:2,USBTINY_CLR:3,USBTINY_SET:4,U
 105               		.stabs	"spi:f(0,15)",36,0,126,spi
 106               		.stabs	"cmd:P(0,17)=*(0,11)",64,0,125,26
 107               		.stabs	"res:P(0,17)",64,0,125,30
 108               		.type	spi, @function
 109               	spi:
 110               		.stabd	46,0,0
   0:main.c        **** /* Name: main.c
   1:main.c        ****   
   2:main.c        ****   created by chris chung, 2010 April
   3:main.c        **** 
GAS LISTING /tmp/ccZgsOoQ.s 			page 3


   4:main.c        ****   based on the works found in
   5:main.c        **** 
   6:main.c        ****   v-usb framework http://www.obdev.at/vusb/
   7:main.c        **** 	 Project: Thermostat based on AVR USB driver
   8:main.c        **** 	 Author: Christian Starkjohann
   9:main.c        ****     
  10:main.c        ****   usbtiny isp http://www.xs4all.nl/~dicks/avr/usbtiny/
  11:main.c        ****   	Dick Streefland
  12:main.c        ****   
  13:main.c        ****   please observe licensing term from the above two projects
  14:main.c        **** 
  15:main.c        **** 	Copyright (C) 2010  chris chung
  16:main.c        **** 
  17:main.c        **** 	This program is free software; you can redistribute it and/or
  18:main.c        **** 	modify it under the terms of the GNU General Public License
  19:main.c        **** 	as published by the Free Software Foundation; either version 2
  20:main.c        **** 	of the License, or (at your option) any later version.
  21:main.c        **** 
  22:main.c        **** 	This program is distributed in the hope that it will be useful,
  23:main.c        **** 	but WITHOUT ANY WARRANTY; without even the implied warranty of
  24:main.c        **** 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  25:main.c        **** 	GNU General Public License for more details.
  26:main.c        **** 
  27:main.c        **** 	You should have received a copy of the GNU General Public License
  28:main.c        **** 	along with this program; if not, write to the Free Software
  29:main.c        **** 	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  30:main.c        **** 
  31:main.c        **** 
  32:main.c        ****   **** fuse setting, 
  33:main.c        ****   **** this will blow reset fuse, u will need to use HV programmer to recover if u mess up
  34:main.c        ****   avrdude -c usbtiny -p t45 -V -U lfuse:w:0xe1:m -U hfuse:w:0x5d:m -U efuse:w:0xff:m 
  35:main.c        ****  */
  36:main.c        **** 
  37:main.c        **** #include <avr/io.h>
  38:main.c        **** #include <avr/wdt.h>
  39:main.c        **** #include <avr/eeprom.h>
  40:main.c        **** #include <avr/interrupt.h>
  41:main.c        **** #include <avr/pgmspace.h>
  42:main.c        **** #include <util/delay.h>
  43:main.c        **** #include <stdlib.h>
  44:main.c        **** 
  45:main.c        **** #include "usbdrv.h"
  46:main.c        **** #include "oddebug.h"
  47:main.c        **** 
  48:main.c        **** enum
  49:main.c        **** {
  50:main.c        **** 	// Generic requests
  51:main.c        **** 	USBTINY_ECHO,		// echo test
  52:main.c        **** 	USBTINY_READ,		// read byte (wIndex:address)
  53:main.c        **** 	USBTINY_WRITE,		// write byte (wIndex:address, wValue:value)
  54:main.c        **** 	USBTINY_CLR,		// clear bit (wIndex:address, wValue:bitno)
  55:main.c        **** 	USBTINY_SET,		// set bit (wIndex:address, wValue:bitno)
  56:main.c        **** 	// Programming requests
  57:main.c        **** 	USBTINY_POWERUP,	// apply power (wValue:SCK-period, wIndex:RESET)
  58:main.c        **** 	USBTINY_POWERDOWN,	// remove power from chip
  59:main.c        **** 	USBTINY_SPI,		// issue SPI command (wValue:c1c0, wIndex:c3c2)
  60:main.c        **** 	USBTINY_POLL_BYTES,	// set poll bytes for write (wValue:p1p2)
GAS LISTING /tmp/ccZgsOoQ.s 			page 4


  61:main.c        **** 	USBTINY_FLASH_READ,	// read flash (wIndex:address)
  62:main.c        **** 	USBTINY_FLASH_WRITE,	// write flash (wIndex:address, wValue:timeout)
  63:main.c        **** 	USBTINY_EEPROM_READ,	// read eeprom (wIndex:address)
  64:main.c        **** 	USBTINY_EEPROM_WRITE,	// write eeprom (wIndex:address, wValue:timeout)
  65:main.c        **** };
  66:main.c        **** 
  67:main.c        **** #define	PORT	PORTB
  68:main.c        **** #define	DDR		DDRB
  69:main.c        **** #define	PIN		PINB
  70:main.c        **** 
  71:main.c        **** //
  72:main.c        **** // to reduce pin count so that this can fit in a 8 pin tiny
  73:main.c        **** // . no power nor ground pins to target, they are to be connected always
  74:main.c        **** // . no reset control pin to target, target reset always grounded
  75:main.c        **** //   * this had caused problem and there are two solutions
  76:main.c        **** //     1. provide a toggle switch to off-on-off target reset to ground
  77:main.c        **** //     2. introduce reset control and use reset pin as io
  78:main.c        **** //
  79:main.c        **** #define	POWER_MASK	0x00
  80:main.c        **** #define	GND_MASK	0x00
  81:main.c        **** 
  82:main.c        **** #define	RESET_MASK	(1 << 5)
  83:main.c        **** #define	SCK_MASK	(1 << 2)
  84:main.c        **** #define	MISO_MASK	(1 << 1)
  85:main.c        **** #define	MOSI_MASK	(1 << 0)
  86:main.c        **** 
  87:main.c        **** // ----------------------------------------------------------------------
  88:main.c        **** // Programmer input pins:
  89:main.c        **** //	MISO	PD3	(ACK)
  90:main.c        **** // ----------------------------------------------------------------------
  91:main.c        **** 
  92:main.c        **** // ----------------------------------------------------------------------
  93:main.c        **** // Local data
  94:main.c        **** // ----------------------------------------------------------------------
  95:main.c        **** static	uchar		sck_period=50;	// SCK period in microseconds (1..250)
  96:main.c        **** static	uchar		poll1;		// first poll byte for write
  97:main.c        **** static	uchar		poll2;		// second poll byte for write
  98:main.c        **** static	unsigned		address;	// read/write address
  99:main.c        **** static	unsigned		timeout;	// write timeout in usec
 100:main.c        **** static	uchar		cmd0;		// current read/write command byte
 101:main.c        **** static	uchar		cmd[4];		// SPI command buffer
 102:main.c        **** static	uchar		res[4];		// SPI result buffer
 103:main.c        **** 
 104:main.c        **** // ----------------------------------------------------------------------
 105:main.c        **** // Delay exactly <sck_period> times 0.5 microseconds (6 cycles).
 106:main.c        **** // ----------------------------------------------------------------------
 107:main.c        **** __attribute__((always_inline))
 108:main.c        **** static	void	delay ( void )
 109:main.c        **** {
 110:main.c        **** 	asm volatile(
 111:main.c        **** 		"	mov	__tmp_reg__,%0	\n"
 112:main.c        **** 		"0:	rjmp	1f		\n"
 113:main.c        **** 		"1:	nop			\n"
 114:main.c        **** 		"2:	nop			\n"
 115:main.c        **** 		"3:	nop			\n"
 116:main.c        **** 		"	dec	__tmp_reg__	\n"
 117:main.c        **** 		"	brne	0b		\n"
GAS LISTING /tmp/ccZgsOoQ.s 			page 5


 118:main.c        **** 		: : "r" (sck_period) );
 119:main.c        **** }
 120:main.c        **** 
 121:main.c        **** // ----------------------------------------------------------------------
 122:main.c        **** // Issue one SPI command.
 123:main.c        **** // ----------------------------------------------------------------------
 124:main.c        **** static	void	spi ( uchar* cmd, uchar* res )
 125:main.c        **** {
 111               		.stabn	68,0,126,.LM0-.LFBB1
 112               	.LM0:
 113               	.LFBB1:
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116 0000 DC01      		movw r26,r24
 117 0002 FB01      		movw r30,r22
 118               	.LBB18:
 119               	.LBB19:
 111:main.c        **** 	asm volatile(
 120               		.stabn	68,0,111,.LM1-.LFBB1
 121               	.LM1:
 122 0004 6091 0000 		lds r22,sck_period
 123 0008 50E0      		ldi r21,lo8(0)
 124               	.L6:
 125               	.LBE19:
 126               	.LBE18:
 126:main.c        **** 	uchar	i;
 127:main.c        **** 	uchar	c;
 128:main.c        **** 	uchar	r;
 129:main.c        **** 	uchar	mask;
 130:main.c        **** 
 131:main.c        **** 	for	( i = 0; i < 4; i++ )
 132:main.c        **** 	{
 133:main.c        **** 		c = *cmd++;
 127               		.stabn	68,0,134,.LM2-.LFBB1
 128               	.LM2:
 129 000a 7D91      		ld r23,X+
 130 000c 90E0      		ldi r25,lo8(0)
 131 000e 40E8      		ldi r20,lo8(-128)
 132 0010 20E0      		ldi r18,lo8(0)
 133 0012 30E0      		ldi r19,hi8(0)
 134               	.L4:
 134:main.c        **** 		r = 0;
 135:main.c        **** 		for	( mask = 0x80; mask; mask >>= 1 )
 136:main.c        **** 		{
 137:main.c        **** 			if	( c & mask )
 135               		.stabn	68,0,138,.LM3-.LFBB1
 136               	.LM3:
 137 0014 842F      		mov r24,r20
 138 0016 8723      		and r24,r23
 139 0018 01F0      		breq .L2
 138:main.c        **** 			{
 139:main.c        **** 				PORT |= MOSI_MASK;
 140               		.stabn	68,0,140,.LM4-.LFBB1
 141               	.LM4:
 142 001a C09A      		sbi 56-32,0
 143               	.L2:
 144               	.LBB21:
GAS LISTING /tmp/ccZgsOoQ.s 			page 6


 145               	.LBB20:
 111:main.c        **** 	asm volatile(
 146               		.stabn	68,0,111,.LM5-.LFBB1
 147               	.LM5:
 148               	/* #APP */
 149               	 ;  111 "main.c" 1
 150 001c 062E      			mov	__tmp_reg__,r22	
 151 001e 00C0      	0:	rjmp	1f		
 152 0020 0000      	1:	nop			
 153 0022 0000      	2:	nop			
 154 0024 0000      	3:	nop			
 155 0026 0A94      		dec	__tmp_reg__	
 156 0028 01F4      		brne	0b		
 157               	
 158               	 ;  0 "" 2
 159               	/* #NOAPP */
 160               	.LBE20:
 161               	.LBE21:
 140:main.c        **** 			}
 141:main.c        **** 			delay();
 142:main.c        **** 			PORT |= SCK_MASK;
 162               		.stabn	68,0,143,.LM6-.LFBB1
 163               	.LM6:
 164 002a C29A      		sbi 56-32,2
 165               	.LBB22:
 166               	.LBB23:
 111:main.c        **** 	asm volatile(
 167               		.stabn	68,0,111,.LM7-.LFBB1
 168               	.LM7:
 169               	/* #APP */
 170               	 ;  111 "main.c" 1
 171 002c 062E      			mov	__tmp_reg__,r22	
 172 002e 00C0      	0:	rjmp	1f		
 173 0030 0000      	1:	nop			
 174 0032 0000      	2:	nop			
 175 0034 0000      	3:	nop			
 176 0036 0A94      		dec	__tmp_reg__	
 177 0038 01F4      		brne	0b		
 178               	
 179               	 ;  0 "" 2
 180               	/* #NOAPP */
 181               	.LBE23:
 182               	.LBE22:
 143:main.c        **** 			delay();
 144:main.c        **** 			r <<= 1;
 183               		.stabn	68,0,145,.LM8-.LFBB1
 184               	.LM8:
 185 003a 990F      		lsl r25
 145:main.c        **** 			if	( PIN & MISO_MASK )
 186               		.stabn	68,0,146,.LM9-.LFBB1
 187               	.LM9:
 188 003c B199      		sbic 54-32,1
 146:main.c        **** 			{
 147:main.c        **** 				r++;
 189               		.stabn	68,0,148,.LM10-.LFBB1
 190               	.LM10:
 191 003e 9F5F      		subi r25,lo8(-(1))
GAS LISTING /tmp/ccZgsOoQ.s 			page 7


 192               	.L3:
 148:main.c        **** 			}
 149:main.c        **** 			PORT &= ~MOSI_MASK;
 193               		.stabn	68,0,150,.LM11-.LFBB1
 194               	.LM11:
 195 0040 C098      		cbi 56-32,0
 150:main.c        **** 			PORT &= ~SCK_MASK;
 196               		.stabn	68,0,151,.LM12-.LFBB1
 197               	.LM12:
 198 0042 C298      		cbi 56-32,2
 136:main.c        **** 		for	( mask = 0x80; mask; mask >>= 1 )
 199               		.stabn	68,0,136,.LM13-.LFBB1
 200               	.LM13:
 201 0044 4695      		lsr r20
 202 0046 2F5F      		subi r18,lo8(-(1))
 203 0048 3F4F      		sbci r19,hi8(-(1))
 204 004a 2830      		cpi r18,8
 205 004c 3105      		cpc r19,__zero_reg__
 206 004e 01F4      		brne .L4
 151:main.c        **** 		}
 152:main.c        **** 		*res++ = r;
 207               		.stabn	68,0,153,.LM14-.LFBB1
 208               	.LM14:
 209 0050 9083      		st Z,r25
 132:main.c        **** 	for	( i = 0; i < 4; i++ )
 210               		.stabn	68,0,132,.LM15-.LFBB1
 211               	.LM15:
 212 0052 5F5F      		subi r21,lo8(-(1))
 213 0054 5430      		cpi r21,lo8(4)
 214 0056 01F0      		breq .L7
 215               		.stabn	68,0,153,.LM16-.LFBB1
 216               	.LM16:
 217 0058 3196      		adiw r30,1
 218 005a 00C0      		rjmp .L6
 219               	.L7:
 220 005c 0895      		ret
 221               		.size	spi, .-spi
 222               		.stabs	"i:r(0,11)",64,0,127,21
 223               		.stabs	"c:r(0,11)",64,0,128,23
 224               		.stabs	"r:r(0,11)",64,0,129,25
 225               		.stabs	"mask:r(0,11)",64,0,130,20
 226               		.stabn	192,0,0,.LFBB1-.LFBB1
 227               		.stabn	224,0,0,.Lscope1-.LFBB1
 228               	.Lscope1:
 229               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 230               		.stabd	78,0,0
 231               		.stabs	"spi_rw:f(0,15)",36,0,161,spi_rw
 232               		.type	spi_rw, @function
 233               	spi_rw:
 234               		.stabd	46,0,0
 153:main.c        **** 	}
 154:main.c        **** }
 155:main.c        **** 
 156:main.c        **** // ----------------------------------------------------------------------
 157:main.c        **** // Create and issue a read or write SPI command.
 158:main.c        **** // ----------------------------------------------------------------------
 159:main.c        **** static	void	spi_rw ( void )
GAS LISTING /tmp/ccZgsOoQ.s 			page 8


 160:main.c        **** {
 235               		.stabn	68,0,161,.LM17-.LFBB2
 236               	.LM17:
 237               	.LFBB2:
 238               	/* prologue: function */
 239               	/* frame size = 0 */
 161:main.c        **** 	unsigned	a;
 162:main.c        **** 
 163:main.c        **** 	a = address++;
 240               		.stabn	68,0,164,.LM18-.LFBB2
 241               	.LM18:
 242 005e 2091 0000 		lds r18,address
 243 0062 3091 0000 		lds r19,(address)+1
 244 0066 2F5F      		subi r18,lo8(-(1))
 245 0068 3F4F      		sbci r19,hi8(-(1))
 246 006a 3093 0000 		sts (address)+1,r19
 247 006e 2093 0000 		sts address,r18
 248 0072 2150      		subi r18,lo8(-(-1))
 249 0074 3040      		sbci r19,hi8(-(-1))
 164:main.c        **** 	if	( cmd0 & 0x80 )
 250               		.stabn	68,0,165,.LM19-.LFBB2
 251               	.LM19:
 252 0076 8091 0000 		lds r24,cmd0
 253 007a 87FF      		sbrs r24,7
 254 007c 00C0      		rjmp .L10
 165:main.c        **** 	{	// eeprom
 166:main.c        **** 		a <<= 1;
 255               		.stabn	68,0,167,.LM20-.LFBB2
 256               	.LM20:
 257 007e 220F      		lsl r18
 258 0080 331F      		rol r19
 259               	.L10:
 167:main.c        **** 	}
 168:main.c        **** 	cmd[0] = cmd0;
 260               		.stabn	68,0,169,.LM21-.LFBB2
 261               	.LM21:
 262 0082 8093 0000 		sts cmd,r24
 169:main.c        **** 	if	( a & 1 )
 263               		.stabn	68,0,170,.LM22-.LFBB2
 264               	.LM22:
 265 0086 20FF      		sbrs r18,0
 266 0088 00C0      		rjmp .L11
 170:main.c        **** 	{
 171:main.c        **** 		cmd[0] |= 0x08;
 267               		.stabn	68,0,172,.LM23-.LFBB2
 268               	.LM23:
 269 008a 8860      		ori r24,lo8(8)
 270 008c 8093 0000 		sts cmd,r24
 271               	.L11:
 172:main.c        **** 	}
 173:main.c        **** 	cmd[1] = a >> 9;
 272               		.stabn	68,0,174,.LM24-.LFBB2
 273               	.LM24:
 274 0090 832F      		mov r24,r19
 275 0092 8695      		lsr r24
 276 0094 8093 0000 		sts cmd+1,r24
 174:main.c        **** 	cmd[2] = a >> 1;
GAS LISTING /tmp/ccZgsOoQ.s 			page 9


 277               		.stabn	68,0,175,.LM25-.LFBB2
 278               	.LM25:
 279 0098 3695      		lsr r19
 280 009a 2795      		ror r18
 281 009c 2093 0000 		sts cmd+2,r18
 175:main.c        **** 	spi( cmd, res );
 282               		.stabn	68,0,176,.LM26-.LFBB2
 283               	.LM26:
 284 00a0 80E0      		ldi r24,lo8(cmd)
 285 00a2 90E0      		ldi r25,hi8(cmd)
 286 00a4 60E0      		ldi r22,lo8(res)
 287 00a6 70E0      		ldi r23,hi8(res)
 288 00a8 00D0      		rcall spi
 289               	/* epilogue start */
 176:main.c        **** }
 290               		.stabn	68,0,177,.LM27-.LFBB2
 291               	.LM27:
 292 00aa 0895      		ret
 293               		.size	spi_rw, .-spi_rw
 294               		.stabs	"a:r(0,4)",64,0,162,18
 295               		.stabn	192,0,0,.LFBB2-.LFBB2
 296               		.stabn	224,0,0,.Lscope2-.LFBB2
 297               	.Lscope2:
 298               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 299               		.stabd	78,0,0
 300               		.stabs	"usbFunctionRead:F(0,11)",36,0,183,usbFunctionRead
 301               		.stabs	"len:P(0,11)",64,0,182,16
 302               	.global	usbFunctionRead
 303               		.type	usbFunctionRead, @function
 304               	usbFunctionRead:
 305               		.stabd	46,0,0
 177:main.c        **** 
 178:main.c        **** // ----------------------------------------------------------------------
 179:main.c        **** // Handle an IN packet.
 180:main.c        **** // ----------------------------------------------------------------------
 181:main.c        **** uchar usbFunctionRead(uchar *data, uchar len)
 182:main.c        **** {
 306               		.stabn	68,0,183,.LM28-.LFBB3
 307               	.LM28:
 308               	.LFBB3:
 309 00ac 0F93      		push r16
 310 00ae 1F93      		push r17
 311 00b0 CF93      		push r28
 312 00b2 DF93      		push r29
 313               	/* prologue: function */
 314               	/* frame size = 0 */
 315 00b4 062F      		mov r16,r22
 316               		.stabn	68,0,183,.LM29-.LFBB3
 317               	.LM29:
 318 00b6 EC01      		movw r28,r24
 319 00b8 10E0      		ldi r17,lo8(0)
 320 00ba 00C0      		rjmp .L14
 321               	.L15:
 183:main.c        **** 	uchar	i;
 184:main.c        **** 
 185:main.c        **** 	for	( i = 0; i < len; i++ )
 186:main.c        **** 	{
GAS LISTING /tmp/ccZgsOoQ.s 			page 10


 187:main.c        **** 		spi_rw();
 322               		.stabn	68,0,188,.LM30-.LFBB3
 323               	.LM30:
 324 00bc 00D0      		rcall spi_rw
 188:main.c        **** 		data[i] = res[3];
 325               		.stabn	68,0,189,.LM31-.LFBB3
 326               	.LM31:
 327 00be 8091 0000 		lds r24,res+3
 328 00c2 8993      		st Y+,r24
 186:main.c        **** 	for	( i = 0; i < len; i++ )
 329               		.stabn	68,0,186,.LM32-.LFBB3
 330               	.LM32:
 331 00c4 1F5F      		subi r17,lo8(-(1))
 332               	.L14:
 333 00c6 1017      		cp r17,r16
 334 00c8 00F0      		brlo .L15
 189:main.c        **** 	}
 190:main.c        **** 	return len;
 191:main.c        **** }
 335               		.stabn	68,0,192,.LM33-.LFBB3
 336               	.LM33:
 337 00ca 802F      		mov r24,r16
 338               	/* epilogue start */
 339 00cc DF91      		pop r29
 340 00ce CF91      		pop r28
 341 00d0 1F91      		pop r17
 342 00d2 0F91      		pop r16
 343 00d4 0895      		ret
 344               		.size	usbFunctionRead, .-usbFunctionRead
 345               		.stabs	"i:r(0,11)",64,0,184,17
 346               		.stabn	192,0,0,.LFBB3-.LFBB3
 347               		.stabn	224,0,0,.Lscope3-.LFBB3
 348               	.Lscope3:
 349               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 350               		.stabd	78,0,0
 351               		.stabs	"usbFunctionWrite:F(0,11)",36,0,198,usbFunctionWrite
 352               		.stabs	"len:P(0,11)",64,0,197,8
 353               	.global	usbFunctionWrite
 354               		.type	usbFunctionWrite, @function
 355               	usbFunctionWrite:
 356               		.stabd	46,0,0
 192:main.c        **** 
 193:main.c        **** // ----------------------------------------------------------------------
 194:main.c        **** // Handle an OUT packet.
 195:main.c        **** // ----------------------------------------------------------------------
 196:main.c        **** uchar usbFunctionWrite(uchar *data, uchar len)
 197:main.c        **** {
 357               		.stabn	68,0,198,.LM34-.LFBB4
 358               	.LM34:
 359               	.LFBB4:
 360 00d6 7F92      		push r7
 361 00d8 8F92      		push r8
 362 00da 9F92      		push r9
 363 00dc AF92      		push r10
 364 00de BF92      		push r11
 365 00e0 CF92      		push r12
 366 00e2 DF92      		push r13
GAS LISTING /tmp/ccZgsOoQ.s 			page 11


 367 00e4 EF92      		push r14
 368 00e6 FF92      		push r15
 369 00e8 0F93      		push r16
 370 00ea 1F93      		push r17
 371 00ec CF93      		push r28
 372 00ee DF93      		push r29
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375 00f0 862E      		mov r8,r22
 198:main.c        **** 	uchar	i;
 199:main.c        **** 	unsigned	usec;
 200:main.c        **** 	uchar	r;
 201:main.c        **** 	//uchar	last = (len != 8);
 202:main.c        **** 
 203:main.c        **** 	for	( i = 0; i < len; i++ )
 204:main.c        **** 	{
 205:main.c        **** 		cmd[3] = data[i];
 206:main.c        **** 		spi_rw();
 207:main.c        **** 		cmd[0] ^= 0x60;	// turn write into read
 208:main.c        **** 		//
 209:main.c        **** 		for	( usec = 0; usec < timeout; usec += 32 * sck_period )
 376               		.stabn	68,0,210,.LM35-.LFBB4
 377               	.LM35:
 378 00f2 A090 0000 		lds r10,timeout
 379 00f6 B090 0000 		lds r11,(timeout)+1
 210:main.c        **** 		{	// when timeout > 0, poll until byte is written
 211:main.c        **** 			spi( cmd, res );
 212:main.c        **** 			r = res[3];
 213:main.c        **** 			if	( r == cmd[3] && r != poll1 && r != poll2 )
 380               		.stabn	68,0,214,.LM36-.LFBB4
 381               	.LM36:
 382 00fa 9090 0000 		lds r9,poll1
 383 00fe C090 0000 		lds r12,poll2
 210:main.c        **** 		{	// when timeout > 0, poll until byte is written
 384               		.stabn	68,0,210,.LM37-.LFBB4
 385               	.LM37:
 386 0102 2091 0000 		lds r18,sck_period
 387 0106 E22E      		mov r14,r18
 388 0108 FF24      		clr r15
 389 010a 35E0      		ldi r19,5
 390 010c EE0C      	1:	lsl r14
 391 010e FF1C      		rol r15
 392 0110 3A95      		dec r19
 393 0112 01F4      		brne 1b
 394 0114 8C01      		movw r16,r24
 395 0116 DD24      		clr r13
 208:main.c        **** 		cmd[0] ^= 0x60;	// turn write into read
 396               		.stabn	68,0,208,.LM38-.LFBB4
 397               	.LM38:
 398 0118 20E6      		ldi r18,lo8(96)
 399 011a 722E      		mov r7,r18
 400 011c 00C0      		rjmp .L18
 401               	.L23:
 206:main.c        **** 		cmd[3] = data[i];
 402               		.stabn	68,0,206,.LM39-.LFBB4
 403               	.LM39:
 404 011e F801      		movw r30,r16
GAS LISTING /tmp/ccZgsOoQ.s 			page 12


 405 0120 8081      		ld r24,Z
 406 0122 8093 0000 		sts cmd+3,r24
 207:main.c        **** 		spi_rw();
 407               		.stabn	68,0,207,.LM40-.LFBB4
 408               	.LM40:
 409 0126 00D0      		rcall spi_rw
 208:main.c        **** 		cmd[0] ^= 0x60;	// turn write into read
 410               		.stabn	68,0,208,.LM41-.LFBB4
 411               	.LM41:
 412 0128 8091 0000 		lds r24,cmd
 413 012c 8725      		eor r24,r7
 414 012e 8093 0000 		sts cmd,r24
 415 0132 C0E0      		ldi r28,lo8(0)
 416 0134 D0E0      		ldi r29,hi8(0)
 417 0136 00C0      		rjmp .L19
 418               	.L22:
 212:main.c        **** 			spi( cmd, res );
 419               		.stabn	68,0,212,.LM42-.LFBB4
 420               	.LM42:
 421 0138 80E0      		ldi r24,lo8(cmd)
 422 013a 90E0      		ldi r25,hi8(cmd)
 423 013c 60E0      		ldi r22,lo8(res)
 424 013e 70E0      		ldi r23,hi8(res)
 425 0140 00D0      		rcall spi
 213:main.c        **** 			r = res[3];
 426               		.stabn	68,0,213,.LM43-.LFBB4
 427               	.LM43:
 428 0142 9091 0000 		lds r25,res+3
 429               		.stabn	68,0,214,.LM44-.LFBB4
 430               	.LM44:
 431 0146 8091 0000 		lds r24,cmd+3
 432 014a 9817      		cp r25,r24
 433 014c 01F4      		brne .L20
 434 014e 9915      		cp r25,r9
 435 0150 01F0      		breq .L20
 436 0152 9C15      		cp r25,r12
 437 0154 01F4      		brne .L21
 438               	.L20:
 210:main.c        **** 		for	( usec = 0; usec < timeout; usec += 32 * sck_period )
 439               		.stabn	68,0,210,.LM45-.LFBB4
 440               	.LM45:
 441 0156 CE0D      		add r28,r14
 442 0158 DF1D      		adc r29,r15
 443               	.L19:
 444 015a CA15      		cp r28,r10
 445 015c DB05      		cpc r29,r11
 446 015e 00F0      		brlo .L22
 447               	.L21:
 204:main.c        **** 	for	( i = 0; i < len; i++ )
 448               		.stabn	68,0,204,.LM46-.LFBB4
 449               	.LM46:
 450 0160 D394      		inc r13
 451 0162 0F5F      		subi r16,lo8(-(1))
 452 0164 1F4F      		sbci r17,hi8(-(1))
 453               	.L18:
 454 0166 D814      		cp r13,r8
 455 0168 00F0      		brlo .L23
GAS LISTING /tmp/ccZgsOoQ.s 			page 13


 214:main.c        **** 			{
 215:main.c        **** 				break;
 216:main.c        **** 			}
 217:main.c        **** 		}
 218:main.c        **** 		//
 219:main.c        **** 	}
 220:main.c        **** 	//return last;
 221:main.c        **** 	return 1;
 222:main.c        **** }
 456               		.stabn	68,0,223,.LM47-.LFBB4
 457               	.LM47:
 458 016a 81E0      		ldi r24,lo8(1)
 459               	/* epilogue start */
 460 016c DF91      		pop r29
 461 016e CF91      		pop r28
 462 0170 1F91      		pop r17
 463 0172 0F91      		pop r16
 464 0174 FF90      		pop r15
 465 0176 EF90      		pop r14
 466 0178 DF90      		pop r13
 467 017a CF90      		pop r12
 468 017c BF90      		pop r11
 469 017e AF90      		pop r10
 470 0180 9F90      		pop r9
 471 0182 8F90      		pop r8
 472 0184 7F90      		pop r7
 473 0186 0895      		ret
 474               		.size	usbFunctionWrite, .-usbFunctionWrite
 475               		.stabs	"i:r(0,11)",64,0,199,13
 476               		.stabs	"usec:r(0,4)",64,0,200,28
 477               		.stabs	"r:r(0,11)",64,0,201,25
 478               		.stabn	192,0,0,.LFBB4-.LFBB4
 479               		.stabn	224,0,0,.Lscope4-.LFBB4
 480               	.Lscope4:
 481               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 482               		.stabd	78,0,0
 483               		.stabs	"usbFunctionSetup:F(0,11)",36,0,230,usbFunctionSetup
 484               		.stabs	"data:P(0,17)",64,0,229,28
 485               	.global	usbFunctionSetup
 486               		.type	usbFunctionSetup, @function
 487               	usbFunctionSetup:
 488               		.stabd	46,0,0
 223:main.c        **** 
 224:main.c        **** /* ------------------------------------------------------------------------- */
 225:main.c        **** /* ------------------------ interface to USB driver ------------------------ */
 226:main.c        **** /* ------------------------------------------------------------------------- */
 227:main.c        **** 
 228:main.c        **** uchar	usbFunctionSetup(uchar data[8])
 229:main.c        **** {
 489               		.stabn	68,0,230,.LM48-.LFBB5
 490               	.LM48:
 491               	.LFBB5:
 492 0188 CF93      		push r28
 493 018a DF93      		push r29
 494               	/* prologue: function */
 495               	/* frame size = 0 */
 496 018c EC01      		movw r28,r24
GAS LISTING /tmp/ccZgsOoQ.s 			page 14


 230:main.c        **** // ----------------------------------------------------------------------
 231:main.c        **** // Handle a non-standard SETUP packet.
 232:main.c        **** // ----------------------------------------------------------------------
 233:main.c        **** 	uchar	bit;
 234:main.c        **** 	uchar	mask;
 235:main.c        **** 	uchar*	addr;
 236:main.c        **** 	uchar	req;
 237:main.c        **** 
 238:main.c        **** 	// Generic requests
 239:main.c        **** 	req = data[1];
 497               		.stabn	68,0,240,.LM49-.LFBB5
 498               	.LM49:
 499 018e 3981      		ldd r19,Y+1
 240:main.c        **** 	if	( req == USBTINY_ECHO )
 500               		.stabn	68,0,241,.LM50-.LFBB5
 501               	.LM50:
 502 0190 3323      		tst r19
 503 0192 01F4      		brne .L26
 241:main.c        **** 	{
 242:main.c        **** 		usbMsgPtr = data;
 504               		.stabn	68,0,243,.LM51-.LFBB5
 505               	.LM51:
 506 0194 9093 0000 		sts (usbMsgPtr)+1,r25
 507 0198 8093 0000 		sts usbMsgPtr,r24
 508 019c 88E0      		ldi r24,lo8(8)
 509 019e 00C0      		rjmp .L27
 510               	.L26:
 243:main.c        **** 		return 8;
 244:main.c        **** 	}
 245:main.c        **** 	addr = (uchar*) (int) data[4];
 511               		.stabn	68,0,246,.LM52-.LFBB5
 512               	.LM52:
 513 01a0 5C81      		ldd r21,Y+4
 514 01a2 E52F      		mov r30,r21
 515 01a4 F0E0      		ldi r31,lo8(0)
 246:main.c        **** 	if	( req == USBTINY_READ )
 516               		.stabn	68,0,247,.LM53-.LFBB5
 517               	.LM53:
 518 01a6 3130      		cpi r19,lo8(1)
 519 01a8 01F4      		brne .L28
 247:main.c        **** 	{
 248:main.c        **** 		data[0] = *addr;
 520               		.stabn	68,0,249,.LM54-.LFBB5
 521               	.LM54:
 522 01aa 8081      		ld r24,Z
 523 01ac 8883      		st Y,r24
 249:main.c        **** 		usbMsgPtr = data;
 524               		.stabn	68,0,250,.LM55-.LFBB5
 525               	.LM55:
 526 01ae D093 0000 		sts (usbMsgPtr)+1,r29
 527 01b2 C093 0000 		sts usbMsgPtr,r28
 528 01b6 81E0      		ldi r24,lo8(1)
 529 01b8 00C0      		rjmp .L27
 530               	.L28:
 250:main.c        **** 		return 1;
 251:main.c        **** 	}
 252:main.c        **** 	if	( req == USBTINY_WRITE )
GAS LISTING /tmp/ccZgsOoQ.s 			page 15


 531               		.stabn	68,0,253,.LM56-.LFBB5
 532               	.LM56:
 533 01ba 3230      		cpi r19,lo8(2)
 534 01bc 01F4      		brne .L29
 253:main.c        **** 	{
 254:main.c        **** 		*addr = data[2];
 535               		.stabn	68,0,255,.LM57-.LFBB5
 536               	.LM57:
 537 01be 8A81      		ldd r24,Y+2
 538 01c0 00C0      		rjmp .L45
 539               	.L29:
 255:main.c        **** 		return 0;
 256:main.c        **** 	}
 257:main.c        **** 	bit = data[2] & 7;
 540               		.stabn	68,0,258,.LM58-.LFBB5
 541               	.LM58:
 542 01c2 BC01      		movw r22,r24
 543 01c4 6E5F      		subi r22,lo8(-(2))
 544 01c6 7F4F      		sbci r23,hi8(-(2))
 545 01c8 4A81      		ldd r20,Y+2
 258:main.c        **** 	mask = 1 << bit;
 546               		.stabn	68,0,259,.LM59-.LFBB5
 547               	.LM59:
 548 01ca 242F      		mov r18,r20
 549 01cc 2770      		andi r18,lo8(7)
 550 01ce 81E0      		ldi r24,lo8(1)
 551 01d0 90E0      		ldi r25,hi8(1)
 552 01d2 982F      		mov r25,r24
 553 01d4 00C0      		rjmp 2f
 554 01d6 990F      	1:	lsl r25
 555 01d8 2A95      	2:	dec r18
 556 01da 02F4      		brpl 1b
 259:main.c        **** 	if	( req == USBTINY_CLR )
 557               		.stabn	68,0,260,.LM60-.LFBB5
 558               	.LM60:
 559 01dc 3330      		cpi r19,lo8(3)
 560 01de 01F4      		brne .L30
 260:main.c        **** 	{
 261:main.c        **** 		*addr &= ~ mask;
 561               		.stabn	68,0,262,.LM61-.LFBB5
 562               	.LM61:
 563 01e0 9095      		com r25
 564 01e2 8081      		ld r24,Z
 565 01e4 8923      		and r24,r25
 566               	.L45:
 567 01e6 8083      		st Z,r24
 568 01e8 00C0      		rjmp .L44
 569               	.L30:
 262:main.c        **** 		return 0;
 263:main.c        **** 	}
 264:main.c        **** 	if	( req == USBTINY_SET )
 570               		.stabn	68,0,265,.LM62-.LFBB5
 571               	.LM62:
 572 01ea 3430      		cpi r19,lo8(4)
 573 01ec 01F4      		brne .L31
 265:main.c        **** 	{
 266:main.c        **** 		*addr |= mask;
GAS LISTING /tmp/ccZgsOoQ.s 			page 16


 574               		.stabn	68,0,267,.LM63-.LFBB5
 575               	.LM63:
 576 01ee 8081      		ld r24,Z
 577 01f0 892B      		or r24,r25
 578 01f2 00C0      		rjmp .L45
 579               	.L31:
 267:main.c        **** 		return 0;
 268:main.c        **** 	}
 269:main.c        **** 
 270:main.c        **** 	// Programming requests
 271:main.c        **** 	if	( req == USBTINY_POWERUP )
 580               		.stabn	68,0,272,.LM64-.LFBB5
 581               	.LM64:
 582 01f4 3530      		cpi r19,lo8(5)
 583 01f6 01F4      		brne .L32
 272:main.c        **** 	{
 273:main.c        **** 		sck_period = data[2];
 584               		.stabn	68,0,274,.LM65-.LFBB5
 585               	.LM65:
 586 01f8 4093 0000 		sts sck_period,r20
 274:main.c        **** 		mask = POWER_MASK;
 275:main.c        **** 		if	( data[4] )
 587               		.stabn	68,0,276,.LM66-.LFBB5
 588               	.LM66:
 589 01fc 5523      		tst r21
 590 01fe 01F0      		breq .L33
 591 0200 90E2      		ldi r25,lo8(32)
 592 0202 00C0      		rjmp .L34
 593               	.L33:
 594 0204 90E0      		ldi r25,lo8(0)
 595               	.L34:
 276:main.c        **** 		{
 277:main.c        **** 			mask |= RESET_MASK;
 278:main.c        **** 		}
 279:main.c        **** 		DDR  &= ~MISO_MASK;
 596               		.stabn	68,0,280,.LM67-.LFBB5
 597               	.LM67:
 598 0206 B998      		cbi 55-32,1
 280:main.c        **** 		DDR  |= (RESET_MASK|SCK_MASK|MOSI_MASK);
 599               		.stabn	68,0,281,.LM68-.LFBB5
 600               	.LM68:
 601 0208 87B3      		in r24,55-32
 602 020a 8562      		ori r24,lo8(37)
 603 020c 87BB      		out 55-32,r24
 281:main.c        **** 		PORT &= ~(RESET_MASK|SCK_MASK|MOSI_MASK|MISO_MASK);
 604               		.stabn	68,0,282,.LM69-.LFBB5
 605               	.LM69:
 606 020e 88B3      		in r24,56-32
 607 0210 887D      		andi r24,lo8(-40)
 608 0212 88BB      		out 56-32,r24
 282:main.c        **** 		PORT |= mask; // clifford did it ;)
 609               		.stabn	68,0,283,.LM70-.LFBB5
 610               	.LM70:
 611 0214 88B3      		in r24,56-32
 612 0216 982B      		or r25,r24
 613 0218 98BB      		out 56-32,r25
 614 021a 00C0      		rjmp .L44
GAS LISTING /tmp/ccZgsOoQ.s 			page 17


 615               	.L32:
 283:main.c        **** 
 284:main.c        **** 		return 0;
 285:main.c        **** 	}
 286:main.c        **** 	if	( req == USBTINY_POWERDOWN )
 616               		.stabn	68,0,287,.LM71-.LFBB5
 617               	.LM71:
 618 021c 3630      		cpi r19,lo8(6)
 619 021e 01F4      		brne .L35
 287:main.c        **** 	{
 288:main.c        **** 		//PORT |= RESET_MASK;
 289:main.c        **** 		//DDR  &= ~(SCK_MASK|MOSI_MASK);
 290:main.c        **** 		DDRB  = RESET_MASK;
 620               		.stabn	68,0,291,.LM72-.LFBB5
 621               	.LM72:
 622 0220 80E2      		ldi r24,lo8(32)
 623 0222 87BB      		out 55-32,r24
 291:main.c        **** 		PORTB = RESET_MASK;
 624               		.stabn	68,0,292,.LM73-.LFBB5
 625               	.LM73:
 626 0224 88BB      		out 56-32,r24
 627 0226 00C0      		rjmp .L44
 628               	.L35:
 292:main.c        **** 		return 0;
 293:main.c        **** 	}
 294:main.c        **** 	/* have to remove the following check as we strip a lot of io
 295:main.c        **** 	if	( ! PORT )
 296:main.c        **** 	{
 297:main.c        **** 		return 0;
 298:main.c        **** 	}
 299:main.c        **** 	*/
 300:main.c        **** 	if	( req == USBTINY_SPI )
 629               		.stabn	68,0,301,.LM74-.LFBB5
 630               	.LM74:
 631 0228 3730      		cpi r19,lo8(7)
 632 022a 01F4      		brne .L36
 301:main.c        **** 	{
 302:main.c        **** 		spi( data + 2, data + 0 );
 633               		.stabn	68,0,303,.LM75-.LFBB5
 634               	.LM75:
 635 022c CB01      		movw r24,r22
 636 022e BE01      		movw r22,r28
 637 0230 00D0      		rcall spi
 303:main.c        **** 		usbMsgPtr = data;
 638               		.stabn	68,0,304,.LM76-.LFBB5
 639               	.LM76:
 640 0232 D093 0000 		sts (usbMsgPtr)+1,r29
 641 0236 C093 0000 		sts usbMsgPtr,r28
 642 023a 84E0      		ldi r24,lo8(4)
 643 023c 00C0      		rjmp .L27
 644               	.L36:
 304:main.c        **** 		return 4;
 305:main.c        **** 	}
 306:main.c        **** 	if	( req == USBTINY_POLL_BYTES )
 645               		.stabn	68,0,307,.LM77-.LFBB5
 646               	.LM77:
 647 023e 3830      		cpi r19,lo8(8)
GAS LISTING /tmp/ccZgsOoQ.s 			page 18


 648 0240 01F4      		brne .L37
 307:main.c        **** 	{
 308:main.c        **** 		poll1 = data[2];
 649               		.stabn	68,0,309,.LM78-.LFBB5
 650               	.LM78:
 651 0242 4093 0000 		sts poll1,r20
 309:main.c        **** 		poll2 = data[3];
 652               		.stabn	68,0,310,.LM79-.LFBB5
 653               	.LM79:
 654 0246 8B81      		ldd r24,Y+3
 655 0248 8093 0000 		sts poll2,r24
 656 024c 00C0      		rjmp .L44
 657               	.L37:
 310:main.c        **** 		return 0;
 311:main.c        **** 	}
 312:main.c        **** 	address = * (unsigned*) & data[4];
 658               		.stabn	68,0,313,.LM80-.LFBB5
 659               	.LM80:
 660 024e 8C81      		ldd r24,Y+4
 661 0250 9D81      		ldd r25,Y+5
 662 0252 9093 0000 		sts (address)+1,r25
 663 0256 8093 0000 		sts address,r24
 313:main.c        **** 	if	( req == USBTINY_FLASH_READ )
 664               		.stabn	68,0,314,.LM81-.LFBB5
 665               	.LM81:
 666 025a 3930      		cpi r19,lo8(9)
 667 025c 01F4      		brne .L38
 314:main.c        **** 	{
 315:main.c        **** 		cmd0 = 0x20;
 668               		.stabn	68,0,316,.LM82-.LFBB5
 669               	.LM82:
 670 025e 80E2      		ldi r24,lo8(32)
 671 0260 00C0      		rjmp .L43
 672               	.L38:
 316:main.c        **** 		return 0xff;	// usb_in() will be called to get the data
 317:main.c        **** 	}
 318:main.c        **** 	if	( req == USBTINY_EEPROM_READ )
 673               		.stabn	68,0,319,.LM83-.LFBB5
 674               	.LM83:
 675 0262 3B30      		cpi r19,lo8(11)
 676 0264 01F4      		brne .L39
 319:main.c        **** 	{
 320:main.c        **** 		cmd0 = 0xa0;
 677               		.stabn	68,0,321,.LM84-.LFBB5
 678               	.LM84:
 679 0266 80EA      		ldi r24,lo8(-96)
 680 0268 00C0      		rjmp .L43
 681               	.L39:
 321:main.c        **** 		return 0xff;	// usb_in() will be called to get the data
 322:main.c        **** 	}
 323:main.c        **** 	timeout = * (unsigned*) & data[2];
 682               		.stabn	68,0,324,.LM85-.LFBB5
 683               	.LM85:
 684 026a 8A81      		ldd r24,Y+2
 685 026c 9B81      		ldd r25,Y+3
 686 026e 9093 0000 		sts (timeout)+1,r25
 687 0272 8093 0000 		sts timeout,r24
GAS LISTING /tmp/ccZgsOoQ.s 			page 19


 324:main.c        **** 	if	( req == USBTINY_FLASH_WRITE )
 688               		.stabn	68,0,325,.LM86-.LFBB5
 689               	.LM86:
 690 0276 3A30      		cpi r19,lo8(10)
 691 0278 01F4      		brne .L40
 325:main.c        **** 	{
 326:main.c        **** 		cmd0 = 0x40;
 692               		.stabn	68,0,327,.LM87-.LFBB5
 693               	.LM87:
 694 027a 80E4      		ldi r24,lo8(64)
 695 027c 00C0      		rjmp .L43
 696               	.L40:
 327:main.c        **** 		return 0xff;	// data will be received by usb_out()
 328:main.c        **** 	}
 329:main.c        **** 	if	( req == USBTINY_EEPROM_WRITE )
 697               		.stabn	68,0,330,.LM88-.LFBB5
 698               	.LM88:
 699 027e 3C30      		cpi r19,lo8(12)
 700 0280 01F0      		breq .L41
 701               	.L44:
 702 0282 80E0      		ldi r24,lo8(0)
 703 0284 00C0      		rjmp .L27
 704               	.L41:
 330:main.c        **** 	{
 331:main.c        **** 		cmd0 = 0xc0;
 705               		.stabn	68,0,332,.LM89-.LFBB5
 706               	.LM89:
 707 0286 80EC      		ldi r24,lo8(-64)
 708               	.L43:
 709 0288 8093 0000 		sts cmd0,r24
 710 028c 8FEF      		ldi r24,lo8(-1)
 711               	.L27:
 712               	/* epilogue start */
 332:main.c        **** 		return 0xff;	// data will be received by usb_out()
 333:main.c        **** 	}
 334:main.c        **** 	return 0;
 335:main.c        **** }
 713               		.stabn	68,0,336,.LM90-.LFBB5
 714               	.LM90:
 715 028e DF91      		pop r29
 716 0290 CF91      		pop r28
 717 0292 0895      		ret
 718               		.size	usbFunctionSetup, .-usbFunctionSetup
 719               		.stabs	"mask:r(0,11)",64,0,235,25
 720               		.stabs	"addr:r(0,17)",64,0,236,30
 721               		.stabs	"req:r(0,11)",64,0,237,19
 722               		.stabn	192,0,0,.LFBB5-.LFBB5
 723               		.stabn	224,0,0,.Lscope5-.LFBB5
 724               	.Lscope5:
 725               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 726               		.stabd	78,0,0
 727               		.stabs	"main:F(0,1)",36,0,404,main
 728               	.global	main
 729               		.type	main, @function
 730               	main:
 731               		.stabd	46,0,0
 336:main.c        **** 
GAS LISTING /tmp/ccZgsOoQ.s 			page 20


 337:main.c        **** 
 338:main.c        **** /* ------------------------------------------------------------------------- */
 339:main.c        **** /* ------------------------ Oscillator Calibration ------------------------- */
 340:main.c        **** /* ------------------------------------------------------------------------- */
 341:main.c        **** 
 342:main.c        **** /* Calibrate the RC oscillator to 8.25 MHz. The core clock of 16.5 MHz is
 343:main.c        ****  * derived from the 66 MHz peripheral clock by dividing. Our timing reference
 344:main.c        ****  * is the Start Of Frame signal (a single SE0 bit) available immediately after
 345:main.c        ****  * a USB RESET. We first do a binary search for the OSCCAL value and then
 346:main.c        ****  * optimize this value with a neighboorhod search.
 347:main.c        ****  * This algorithm may also be used to calibrate the RC oscillator directly to
 348:main.c        ****  * 12 MHz (no PLL involved, can therefore be used on almost ALL AVRs), but this
 349:main.c        ****  * is wide outside the spec for the OSCCAL value and the required precision for
 350:main.c        ****  * the 12 MHz clock! Use the RC oscillator calibrated to 12 MHz for
 351:main.c        ****  * experimental purposes only!
 352:main.c        ****  */
 353:main.c        **** static void calibrateOscillator(void)
 354:main.c        **** {
 355:main.c        **** uchar       step = 128;
 356:main.c        **** uchar       trialValue = 0, optimumValue;
 357:main.c        **** int         x, optimumDev, targetValue = (unsigned)(1499 * (double)F_CPU / 10.5e6 + 0.5);
 358:main.c        **** 
 359:main.c        ****     /* do a binary search: */
 360:main.c        ****     do{
 361:main.c        ****         OSCCAL = trialValue + step;
 362:main.c        ****         x = usbMeasureFrameLength();    /* proportional to current real frequency */
 363:main.c        ****         if(x < targetValue)             /* frequency still too low */
 364:main.c        ****             trialValue += step;
 365:main.c        ****         step >>= 1;
 366:main.c        ****     }while(step > 0);
 367:main.c        ****     /* We have a precision of +/- 1 for optimum OSCCAL here */
 368:main.c        ****     /* now do a neighborhood search for optimum value */
 369:main.c        ****     optimumValue = trialValue;
 370:main.c        ****     optimumDev = x; /* this is certainly far away from optimum */
 371:main.c        ****     for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
 372:main.c        ****         x = usbMeasureFrameLength() - targetValue;
 373:main.c        ****         if(x < 0)
 374:main.c        ****             x = -x;
 375:main.c        ****         if(x < optimumDev){
 376:main.c        ****             optimumDev = x;
 377:main.c        ****             optimumValue = OSCCAL;
 378:main.c        ****         }
 379:main.c        ****     }
 380:main.c        ****     OSCCAL = optimumValue;
 381:main.c        **** }
 382:main.c        **** /*
 383:main.c        **** Note: This calibration algorithm may try OSCCAL values of up to 192 even if
 384:main.c        **** the optimum value is far below 192. It may therefore exceed the allowed clock
 385:main.c        **** frequency of the CPU in low voltage designs!
 386:main.c        **** You may replace this search algorithm with any other algorithm you like if
 387:main.c        **** you have additional constraints such as a maximum CPU clock.
 388:main.c        **** For version 5.x RC oscillators (those with a split range of 2x128 steps, e.g.
 389:main.c        **** ATTiny25, ATTiny45, ATTiny85), it may be useful to search for the optimum in
 390:main.c        **** both regions.
 391:main.c        **** */
 392:main.c        **** 
 393:main.c        **** void    usbEventResetReady(void)
GAS LISTING /tmp/ccZgsOoQ.s 			page 21


 394:main.c        **** {
 395:main.c        ****     calibrateOscillator();
 396:main.c        ****     eeprom_write_byte(0, OSCCAL);   /* store the calibrated value in EEPROM */
 397:main.c        **** }
 398:main.c        **** 
 399:main.c        **** /* ------------------------------------------------------------------------- */
 400:main.c        **** /* --------------------------------- main ---------------------------------- */
 401:main.c        **** /* ------------------------------------------------------------------------- */
 402:main.c        **** 
 403:main.c        **** int main(void) {
 732               		.stabn	68,0,404,.LM91-.LFBB6
 733               	.LM91:
 734               	.LFBB6:
 735               	/* prologue: function */
 736               	/* frame size = 0 */
 404:main.c        **** 	uchar   i;
 405:main.c        **** 	uchar   calibrationValue;
 406:main.c        **** 
 407:main.c        **** 	//DDRB  = (RESET_MASK|SCK_MASK|MOSI_MASK);
 408:main.c        **** 	DDRB  = RESET_MASK;
 737               		.stabn	68,0,409,.LM92-.LFBB6
 738               	.LM92:
 739 0294 80E2      		ldi r24,lo8(32)
 740 0296 87BB      		out 55-32,r24
 409:main.c        **** 	PORTB = RESET_MASK;
 741               		.stabn	68,0,410,.LM93-.LFBB6
 742               	.LM93:
 743 0298 88BB      		out 56-32,r24
 410:main.c        **** 	/*
 411:main.c        **** 	_delay_ms(25);
 412:main.c        **** 	uchar pgm[] = { 0xac, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
 413:main.c        **** 	spi(pgm, pgm+4);
 414:main.c        **** 	*/
 415:main.c        ****     calibrationValue = eeprom_read_byte(0); /* calibration value from last time */
 744               		.stabn	68,0,416,.LM94-.LFBB6
 745               	.LM94:
 746 029a 80E0      		ldi r24,lo8(0)
 747 029c 90E0      		ldi r25,hi8(0)
 748 029e 00D0      		rcall __eerd_byte_tn45
 416:main.c        ****     if(calibrationValue != 0xff){
 749               		.stabn	68,0,417,.LM95-.LFBB6
 750               	.LM95:
 751 02a0 8F3F      		cpi r24,lo8(-1)
 752 02a2 01F0      		breq .L47
 417:main.c        ****         OSCCAL = calibrationValue;
 753               		.stabn	68,0,418,.LM96-.LFBB6
 754               	.LM96:
 755 02a4 81BF      		out 81-32,r24
 756               	.L47:
 418:main.c        ****     }
 419:main.c        ****     odDebugInit();
 420:main.c        ****     usbDeviceDisconnect();
 757               		.stabn	68,0,421,.LM97-.LFBB6
 758               	.LM97:
 759 02a6 BC9A      		sbi 55-32,4
 760 02a8 20E0      		ldi r18,lo8(0)
 761               	.LBB24:
GAS LISTING /tmp/ccZgsOoQ.s 			page 22


 762               	.LBB25:
 763               	.LBB26:
 764               	.LBB27:
 765               		.stabs	"/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h",132,0,0,.Ltext1
 766               	.Ltext1:
   0:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   1:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   2:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
   4:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
   7:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  10:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  15:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  19:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  30:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  31:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  32:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  33:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  34:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  35:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  36:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  37:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  38:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \file */
  39:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  40:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     \code
  41:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  42:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     \endcode
  43:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  45:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  46:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  47:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  48:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  49:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  50:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  51:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
GAS LISTING /tmp/ccZgsOoQ.s 			page 23


  52:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  53:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  54:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  55:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  56:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  57:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  58:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  59:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  60:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  61:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** */
  62:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  63:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  64:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  65:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  66:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #endif
  67:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  68:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  69:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  70:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  71:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  72:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  73:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  74:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     register.
  75:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  76:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  77:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     can be achieved.
  78:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** */
  79:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** void
  80:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  81:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** {
  82:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  83:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  84:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  85:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  86:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  87:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	);
  88:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** }
  89:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  90:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  91:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  92:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  93:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  94:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  95:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  96:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     counter register pair.
  97:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  98:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
  99:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 100:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****  */
 101:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** void
 102:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 103:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** {
 104:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 767               		.stabn	68,0,105,.LM98-.LFBB6
 768               	.LM98:
 769 02aa 43EB      		ldi r20,lo8(-3661)
 770 02ac 51EF      		ldi r21,hi8(-3661)
GAS LISTING /tmp/ccZgsOoQ.s 			page 24


 771               	.L48:
 772 02ae CA01      		movw r24,r20
 773               	/* #APP */
 774               	 ;  105 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 775 02b0 0197      		1: sbiw r24,1
 776 02b2 01F4      		brne 1b
 777               	 ;  0 "" 2
 778               	/* #NOAPP */
 779               	.LBE27:
 780               	.LBE26:
 781               	.LBE25:
 782               	.LBE24:
 783               		.stabs	"main.c",132,0,0,.Ltext2
 784               	.Ltext2:
 421:main.c        ****     for(i=0;i<20;i++){  /* 300 ms disconnect */
 785               		.stabn	68,0,422,.LM99-.LFBB6
 786               	.LM99:
 787 02b4 2F5F      		subi r18,lo8(-(1))
 788 02b6 2431      		cpi r18,lo8(20)
 789 02b8 01F4      		brne .L48
 422:main.c        ****         _delay_ms(15);
 423:main.c        ****     }
 424:main.c        ****     usbDeviceConnect();
 790               		.stabn	68,0,425,.LM100-.LFBB6
 791               	.LM100:
 792 02ba BC98      		cbi 55-32,4
 425:main.c        **** 
 426:main.c        ****     wdt_enable(WDTO_1S);
 793               		.stabn	68,0,427,.LM101-.LFBB6
 794               	.LM101:
 795 02bc 2EE0      		ldi r18,lo8(14)
 796 02be 88E1      		ldi r24,lo8(24)
 797 02c0 90E0      		ldi r25,hi8(24)
 798               	/* #APP */
 799               	 ;  427 "main.c" 1
 800 02c2 0FB6      		in __tmp_reg__,__SREG__
 801 02c4 F894      		cli
 802 02c6 A895      		wdr
 803 02c8 81BD      		out 33,r24
 804 02ca 0FBE      		out __SREG__,__tmp_reg__
 805 02cc 21BD      		out 33,r18
 806               	 ;  0 "" 2
 427:main.c        **** 
 428:main.c        ****     usbInit();
 807               		.stabn	68,0,429,.LM102-.LFBB6
 808               	.LM102:
 809               	/* #NOAPP */
 810 02ce 00D0      		rcall usbInit
 429:main.c        ****     sei();
 811               		.stabn	68,0,430,.LM103-.LFBB6
 812               	.LM103:
 813               	/* #APP */
 814               	 ;  430 "main.c" 1
 815 02d0 7894      		sei
 816               	 ;  0 "" 2
 817               	/* #NOAPP */
 818               	.L49:
GAS LISTING /tmp/ccZgsOoQ.s 			page 25


 430:main.c        ****     for(;;){    /* main event loop */
 431:main.c        ****         wdt_reset();
 819               		.stabn	68,0,432,.LM104-.LFBB6
 820               	.LM104:
 821               	/* #APP */
 822               	 ;  432 "main.c" 1
 823 02d2 A895      		wdr
 824               	 ;  0 "" 2
 432:main.c        ****         usbPoll();
 825               		.stabn	68,0,433,.LM105-.LFBB6
 826               	.LM105:
 827               	/* #NOAPP */
 828 02d4 00D0      		rcall usbPoll
 829 02d6 00C0      		rjmp .L49
 830               		.size	main, .-main
 831               		.stabs	"i:r(0,11)",64,0,405,18
 832               		.stabs	"calibrationValue:r(0,11)",64,0,406,24
 833               		.stabn	192,0,0,.LFBB6-.LFBB6
 834               		.stabn	224,0,0,.Lscope6-.LFBB6
 835               	.Lscope6:
 836               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 837               		.stabd	78,0,0
 838               		.stabs	"usbEventResetReady:F(0,15)",36,0,395,usbEventResetReady
 839               	.global	usbEventResetReady
 840               		.type	usbEventResetReady, @function
 841               	usbEventResetReady:
 842               		.stabd	46,0,0
 395:main.c        **** {
 843               		.stabn	68,0,395,.LM106-.LFBB7
 844               	.LM106:
 845               	.LFBB7:
 846 02d8 DF92      		push r13
 847 02da EF92      		push r14
 848 02dc FF92      		push r15
 849 02de 0F93      		push r16
 850 02e0 1F93      		push r17
 851 02e2 CF93      		push r28
 852 02e4 DF93      		push r29
 853               	/* prologue: function */
 854               	/* frame size = 0 */
 395:main.c        **** {
 855               		.stabn	68,0,395,.LM107-.LFBB7
 856               	.LM107:
 857 02e6 00E0      		ldi r16,lo8(0)
 858 02e8 40E8      		ldi r20,lo8(-128)
 859 02ea D42E      		mov r13,r20
 860 02ec EE24      		clr r14
 861 02ee FF24      		clr r15
 862               	.L55:
 863               	.LBB28:
 864               	.LBB29:
 362:main.c        ****         OSCCAL = trialValue + step;
 865               		.stabn	68,0,362,.LM108-.LFBB7
 866               	.LM108:
 867 02f0 1D2D      		mov r17,r13
 868 02f2 100F      		add r17,r16
 869 02f4 11BF      		out 81-32,r17
GAS LISTING /tmp/ccZgsOoQ.s 			page 26


 870               	.LBE29:
 363:main.c        ****         x = usbMeasureFrameLength();    /* proportional to current real frequency */
 871               		.stabn	68,0,363,.LM109-.LFBB7
 872               	.LM109:
 873 02f6 00D0      		rcall usbMeasureFrameLength
 874               	.LBB30:
 875 02f8 EC01      		movw r28,r24
 364:main.c        ****         if(x < targetValue)             /* frequency still too low */
 876               		.stabn	68,0,364,.LM110-.LFBB7
 877               	.LM110:
 878 02fa 89E0      		ldi r24,hi8(2356)
 879 02fc C433      		cpi r28,lo8(2356)
 880 02fe D807      		cpc r29,r24
 881 0300 04F0      		brlt .L53
 882 0302 102F      		mov r17,r16
 883               	.L53:
 366:main.c        ****         step >>= 1;
 884               		.stabn	68,0,366,.LM111-.LFBB7
 885               	.LM111:
 886 0304 D694      		lsr r13
 887 0306 0894      		sec
 888 0308 E11C      		adc r14,__zero_reg__
 889 030a F11C      		adc r15,__zero_reg__
 367:main.c        ****     }while(step > 0);
 890               		.stabn	68,0,367,.LM112-.LFBB7
 891               	.LM112:
 892 030c 88E0      		ldi r24,lo8(8)
 893 030e E816      		cp r14,r24
 894 0310 F104      		cpc r15,__zero_reg__
 895 0312 01F0      		breq .L54
 896 0314 012F      		mov r16,r17
 897 0316 00C0      		rjmp .L55
 898               	.L54:
 372:main.c        ****     for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
 899               		.stabn	68,0,372,.LM113-.LFBB7
 900               	.LM113:
 901 0318 1150      		subi r17,lo8(-(-1))
 902 031a 11BF      		out 81-32,r17
 903 031c 1F5F      		subi r17,lo8(-(1))
 904 031e E12E      		mov r14,r17
 905 0320 FF24      		clr r15
 906 0322 0894      		sec
 907 0324 E11C      		adc r14,__zero_reg__
 908 0326 F11C      		adc r15,__zero_reg__
 909 0328 00C0      		rjmp .L56
 910               	.L60:
 911               	.LBE30:
 373:main.c        ****         x = usbMeasureFrameLength() - targetValue;
 912               		.stabn	68,0,373,.LM114-.LFBB7
 913               	.LM114:
 914 032a 00D0      		rcall usbMeasureFrameLength
 915               	.LBB31:
 916 032c 9C01      		movw r18,r24
 917 032e 2453      		subi r18,lo8(-(-2356))
 918 0330 3940      		sbci r19,hi8(-(-2356))
 919 0332 37FF      		sbrs r19,7
 920 0334 00C0      		rjmp .L57
GAS LISTING /tmp/ccZgsOoQ.s 			page 27


 921 0336 3095      		com r19
 922 0338 2195      		neg r18
 923 033a 3F4F      		sbci r19,lo8(-1)
 924               	.L57:
 376:main.c        ****         if(x < optimumDev){
 925               		.stabn	68,0,376,.LM115-.LFBB7
 926               	.LM115:
 927 033c 2C17      		cp r18,r28
 928 033e 3D07      		cpc r19,r29
 929 0340 04F0      		brlt .L58
 930 0342 9E01      		movw r18,r28
 931 0344 00C0      		rjmp .L59
 932               	.L58:
 378:main.c        ****             optimumValue = OSCCAL;
 933               		.stabn	68,0,378,.LM116-.LFBB7
 934               	.LM116:
 935 0346 11B7      		in r17,81-32
 936               	.L59:
 372:main.c        ****     for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
 937               		.stabn	68,0,372,.LM117-.LFBB7
 938               	.LM117:
 939 0348 81B7      		in r24,81-32
 940 034a 8F5F      		subi r24,lo8(-(1))
 941 034c 81BF      		out 81-32,r24
 942 034e E901      		movw r28,r18
 943               	.L56:
 944 0350 81B7      		in r24,81-32
 945 0352 90E0      		ldi r25,lo8(0)
 946 0354 E816      		cp r14,r24
 947 0356 F906      		cpc r15,r25
 948 0358 04F4      		brge .L60
 381:main.c        ****     OSCCAL = optimumValue;
 949               		.stabn	68,0,381,.LM118-.LFBB7
 950               	.LM118:
 951 035a 11BF      		out 81-32,r17
 952               	.LBE31:
 953               	.LBE28:
 397:main.c        ****     eeprom_write_byte(0, OSCCAL);   /* store the calibrated value in EEPROM */
 954               		.stabn	68,0,397,.LM119-.LFBB7
 955               	.LM119:
 956 035c 61B7      		in r22,81-32
 957 035e 80E0      		ldi r24,lo8(0)
 958 0360 90E0      		ldi r25,hi8(0)
 959 0362 00D0      		rcall __eewr_byte_tn45
 960               	/* epilogue start */
 398:main.c        **** }
 961               		.stabn	68,0,398,.LM120-.LFBB7
 962               	.LM120:
 963 0364 DF91      		pop r29
 964 0366 CF91      		pop r28
 965 0368 1F91      		pop r17
 966 036a 0F91      		pop r16
 967 036c FF90      		pop r15
 968 036e EF90      		pop r14
 969 0370 DF90      		pop r13
 970 0372 0895      		ret
 971               		.size	usbEventResetReady, .-usbEventResetReady
GAS LISTING /tmp/ccZgsOoQ.s 			page 28


 972               		.stabs	"step:r(0,11)",64,0,356,13
 973               		.stabs	"optimumValue:r(0,11)",64,0,357,17
 974               		.stabs	"optimumDev:r(0,1)",64,0,358,28
 975               		.stabn	192,0,0,.LBB29-.LFBB7
 976               		.stabn	224,0,0,.LBE29-.LFBB7
 977               		.stabs	"step:r(0,11)",64,0,356,13
 978               		.stabs	"optimumValue:r(0,11)",64,0,357,17
 979               		.stabs	"optimumDev:r(0,1)",64,0,358,28
 980               		.stabn	192,0,0,.LBB30-.LFBB7
 981               		.stabn	224,0,0,.LBE30-.LFBB7
 982               		.stabs	"step:r(0,11)",64,0,356,13
 983               		.stabs	"optimumValue:r(0,11)",64,0,357,17
 984               		.stabs	"optimumDev:r(0,1)",64,0,358,28
 985               		.stabn	192,0,0,.LBB31-.LFBB7
 986               		.stabn	224,0,0,.LBE31-.LFBB7
 987               	.Lscope7:
 988               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 989               		.stabd	78,0,0
 990               		.data
 991               		.type	sck_period, @object
 992               		.size	sck_period, 1
 993               	sck_period:
 994 0000 32        		.byte	50
 995               		.lcomm poll1,1
 996               		.lcomm poll2,1
 997               		.lcomm address,2
 998               		.lcomm timeout,2
 999               		.lcomm cmd0,1
 1000               		.lcomm cmd,4
 1001               		.lcomm res,4
 1002               		.stabs	"sck_period:S(0,11)",38,0,96,sck_period
 1003               		.stabs	"poll1:S(0,11)",40,0,97,poll1
 1004               		.stabs	"poll2:S(0,11)",40,0,98,poll2
 1005               		.stabs	"address:S(0,4)",40,0,99,address
 1006               		.stabs	"timeout:S(0,4)",40,0,100,timeout
 1007               		.stabs	"cmd0:S(0,11)",40,0,101,cmd0
 1008               		.stabs	"cmd:S(0,18)=ar(10,4);0;3;(0,11)",40,0,102,cmd
 1009               		.stabs	"res:S(0,18)",40,0,103,res
 1010               		.text
 1011               		.stabs	"",100,0,0,.Letext0
 1012               	.Letext0:
GAS LISTING /tmp/ccZgsOoQ.s 			page 29


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccZgsOoQ.s:2      *ABS*:0000003f __SREG__
     /tmp/ccZgsOoQ.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccZgsOoQ.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccZgsOoQ.s:5      *ABS*:00000034 __CCP__
     /tmp/ccZgsOoQ.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccZgsOoQ.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccZgsOoQ.s:109    .text:00000000 spi
     /tmp/ccZgsOoQ.s:993    .data:00000000 sck_period
     /tmp/ccZgsOoQ.s:233    .text:0000005e spi_rw
     /tmp/ccZgsOoQ.s:996    .bss:00000002 address
     /tmp/ccZgsOoQ.s:998    .bss:00000006 cmd0
     /tmp/ccZgsOoQ.s:999    .bss:00000007 cmd
     /tmp/ccZgsOoQ.s:1000   .bss:0000000b res
     /tmp/ccZgsOoQ.s:304    .text:000000ac usbFunctionRead
     /tmp/ccZgsOoQ.s:355    .text:000000d6 usbFunctionWrite
     /tmp/ccZgsOoQ.s:997    .bss:00000004 timeout
                             .bss:00000000 poll1
     /tmp/ccZgsOoQ.s:995    .bss:00000001 poll2
     /tmp/ccZgsOoQ.s:487    .text:00000188 usbFunctionSetup
     /tmp/ccZgsOoQ.s:730    .text:00000294 main
     /tmp/ccZgsOoQ.s:841    .text:000002d8 usbEventResetReady

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
usbMsgPtr
__eerd_byte_tn45
usbInit
usbPoll
usbMeasureFrameLength
__eewr_byte_tn45
